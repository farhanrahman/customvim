snippet always  always @ ..
	always @(posedge clk) begin
	   
	end

snippet always_comb  always_comb ..
	always_comb begin
	   ${1}
	end

snippet always_ff  always_ff ..
	always_ff @(${1:posedge clk or negedge reset_n})
	   ${2}
	end

snippet always_latch  always_latch ..
	always_latch
	   ${1}
	end
snippet case  case() .. 
	case(${1:expression})
	  ${2:value1}: begin
	     ${3}
	  end
	
	  // other case branches
	
	  default: begin
	
	  end
	endcase
	
snippet case  casex() .. 
	casex(${1:expression})
	  ${2:value1}: begin
	     ${3}
	  end
	
	  // other case branches
	
	  default: begin
	
	  end
	endcase
	
snippet casex  casex() .. 
	casex(${1:expression})
	  ${2:value1}: begin
	     ${3}
	  end
	
	  // other case branches
	
	  default: begin
	
	  end
	endcase
	
snippet case  casez() .. 
	casez(${1:expression})
	  ${2:value1}: begin
	     ${3}
	  end
	
	  // other case branches
	
	  default: begin
	
	  end
	endcase
snippet casez  casez() .. 
	casez(${1:expression})
	  ${2:value1}: begin
	     ${3}
	  end
	
	  // other case branches
	
	  default: begin
	
	  end
	endcase
snippet class  class .. endclass
	class ${1:class_name} extends ${2:base_class};
	   ${4}
	   function new(${3:args});
	      super.new($3);
	
	   endfunction: new
	
	endclass: $1
snippet clocking  clocking .. { .. }
	clocking ${1:name_cb} @(posedge ${2:clock});
	   default input #${3:setup_time} output #${4:hold_time};
	   ${5}
	   // output declarations
	   // input declarations
	endclocking: $1
snippet do  do .. while()
	do begin
	   ${2}
	end while($1);
	
	
snippet enum  enum .. { .. }
	typedef enum {${2}
		      } ${1:name_e};
snippet final  final ..
	final begin
	   ${1}
	end
snippet for  for() .. 
	for(${1:int i = 0}; ${2:i != n}; ${3:++i}) begin
	   ${4}
	end
snippet foreach  foreach(x[i]) ..
	foreach(${1:x}[i]) begin
	   ${2}
	end
snippet forever  forever .. 
	forever begin
	   ${1}
	end
snippet fork  fork .. join
	fork
	   begin
	      ${1}
	   end
	   begin
	
	   end
	join
snippet fork  fork .. join_any
	fork
	   begin
	      ${1}
	   end
	   begin
	
	   end
	join_any
snippet fork  fork .. join_none
	fork
	   begin
	      ${1}
	   end
	   begin
	
	   end
	join_none
snippet function  function .. endfunction
	function ${1:void} ${2:function_name} ($3);
	  ${4}
	endfunction: $2
snippet if  if() .. 
	if(${1:condition}) begin
	   ${2}
	end
	
snippet initial  initial ..
	initial begin
	   ${1}
	end
snippet interface  interface .. { .. }
	// vmm rule 4-4 -- interfaces shall be packaged into the same files as the
	// transactors that use them
	interface ${1:name_if} (// input wire clk,
			     // input wire reset
			     );
	   timeunit 1ns;
	   timeprecision 100ps;
	
	   ${2}
	   // imports
	   // import pkg::*;
	
	   parameter hold_time = 2;     // timeunit is 1ns
	   parameter setup_time = 2;    // change timing values as per requirement
	
	   // Clocking Blocks
	   // just type clocking and tab to invoke snippet
	
	   // Modports
	   // just type modport and tab to invoke snippet
	
	endinterface: $1
snippet modport  modport .. { .. }
	modport ${1:name_mp}
	  (${2}
	   // clocking clocking_cb,
	   // input input_name,
	   // output output_port,
	   // ....
	   );
snippet module  module .. endmodule
	module ${1:module_name} (/*port details*/);
	  ${2}
	endmodule: $1
snippet once  `ifndef XXX; `define XXX; `endif
	\`ifndef ${1:`toupper('_'.substitute(expand('%:t'), '\.', '_', '').'_')`}
	
	\`define $1
	
	${2}
	
	\`endif // Guard
snippet ovm  OVM Agent
	class ${1:ovc_name}_agent extends ovm_agent;
	   ${3}
	   ovm_active_passive_enum is_active;
	   $1_sequencer sequencer;
	   $1_driver driver;
	   $1_monitor monitor;
	
	   \`ovm_component_utils_begin($1_agent)
	      \`ovm_field_enum(ovm_active_passive_enum, is_active, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      monitor=$1_monitor::type_id::create("monitor", this);
	      if (is_active == OVM_ACTIVE) begin
		 driver=$1_driver::type_id::create("driver", this);
		 sequencer=$1_sequencer::type_id::create("sequencer", this);
	      end
	   endfunction: build
	
	   virtual function void connect();
	      if (is_active == OVM_ACTIVE) begin
		 driver.seq_item_port.connect(sequencer.seq_item_export);
	      end
	   endfunction: connect
	
	   virtual function void assign_vif(virtual interface ${2:ovc_if} vif);
	      monitor.vif = vif;
	      if (is_active == OVM_ACTIVE) begin
		 driver.vif=vif;
	      end
	   endfunction: assign_vif
	
	endclass: $1_agent
snippet ovm_agent  OVM Agent
	class ${1:ovc_name}_agent extends ovm_agent;
	   ${3}
	   ovm_active_passive_enum is_active;
	   $1_sequencer sequencer;
	   $1_driver driver;
	   $1_monitor monitor;
	
	   \`ovm_component_utils_begin($1_agent)
	      \`ovm_field_enum(ovm_active_passive_enum, is_active, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      monitor=$1_monitor::type_id::create("monitor", this);
	      if (is_active == OVM_ACTIVE) begin
		 driver=$1_driver::type_id::create("driver", this);
		 sequencer=$1_sequencer::type_id::create("sequencer", this);
	      end
	   endfunction: build
	
	   virtual function void connect();
	      if (is_active == OVM_ACTIVE) begin
		 driver.seq_item_port.connect(sequencer.seq_item_export);
	      end
	   endfunction: connect
	
	   virtual function void assign_vif(virtual interface ${2:ovc_if} vif);
	      monitor.vif = vif;
	      if (is_active == OVM_ACTIVE) begin
		 driver.vif=vif;
	      end
	   endfunction: assign_vif
	
	endclass: $1_agent
snippet ovmagent  OVM Agent
	class ${1:ovc_name}_agent extends ovm_agent;
	   ${3}
	   ovm_active_passive_enum is_active;
	   $1_sequencer sequencer;
	   $1_driver driver;
	   $1_monitor monitor;
	
	   \`ovm_component_utils_begin($1_agent)
	      \`ovm_field_enum(ovm_active_passive_enum, is_active, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      monitor=$1_monitor::type_id::create("monitor", this);
	      if (is_active == OVM_ACTIVE) begin
		 driver=$1_driver::type_id::create("driver", this);
		 sequencer=$1_sequencer::type_id::create("sequencer", this);
	      end
	   endfunction: build
	
	   virtual function void connect();
	      if (is_active == OVM_ACTIVE) begin
		 driver.seq_item_port.connect(sequencer.seq_item_export);
	      end
	   endfunction: connect
	
	   virtual function void assign_vif(virtual interface ${2:ovc_if} vif);
	      monitor.vif = vif;
	      if (is_active == OVM_ACTIVE) begin
		 driver.vif=vif;
	      end
	   endfunction: assign_vif
	
	endclass: $1_agent
snippet ovm  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm_sequence_item  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm_data  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm_data_item  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm_item  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm  OVM Driver
	class ${1:ovc_name}_driver extends ovm_driver #(${2:ovc_item});
	   ${4}
	   string tID;
	   virtual interface ${3:ovc_if} vif;
	   $2 item;
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   \`ovm_component_utils_begin($1_driver)
	      \`ovm_field_object(item, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task get_and_drive();
	      forever
		begin
		   // wait(vif.reset==0);  // block until reset released
		   seq_item_port.get_next_item(item);
		   send_to_dut(item);
		   seq_item_port.item_done();
		end
	   endtask: get_and_drive
	
	   task send_to_dut(input $2 item);
	      ovm_report_info(tID, $psprintf("%s : item sent is %0s",
					     tID, item.sprint()), OVM_FULL);
	      // Send data to DUT (BFM - fill in your BFM code here)
	      #10 ;
	      #10 ;
	   endtask: send_to_dut
	
	   task reset_dut();
	      // fill in any reset code here
	   endtask: reset_dut
	
	   task run();
	      ovm_report_info(tID, $psprintf(" %s : running", tID), OVM_MEDIUM);
	      // reset_dut(); // fill in 'reset_dut()' if needed
	      get_and_drive();
	   endtask: run
	
	   virtual function void report();
	      // fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	endclass: $1_driver
snippet ovm_driver  OVM Driver
	class ${1:ovc_name}_driver extends ovm_driver #(${2:ovc_item});
	   ${4}
	   string tID;
	   virtual interface ${3:ovc_if} vif;
	   $2 item;
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   \`ovm_component_utils_begin($1_driver)
	      \`ovm_field_object(item, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task get_and_drive();
	      forever
		begin
		   // wait(vif.reset==0);  // block until reset released
		   seq_item_port.get_next_item(item);
		   send_to_dut(item);
		   seq_item_port.item_done();
		end
	   endtask: get_and_drive
	
	   task send_to_dut(input $2 item);
	      ovm_report_info(tID, $psprintf("%s : item sent is %0s",
					     tID, item.sprint()), OVM_FULL);
	      // Send data to DUT (BFM - fill in your BFM code here)
	      #10 ;
	      #10 ;
	   endtask: send_to_dut
	
	   task reset_dut();
	      // fill in any reset code here
	   endtask: reset_dut
	
	   task run();
	      ovm_report_info(tID, $psprintf(" %s : running", tID), OVM_MEDIUM);
	      // reset_dut(); // fill in 'reset_dut()' if needed
	      get_and_drive();
	   endtask: run
	
	   virtual function void report();
	      // fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	endclass: $1_driver
snippet ovmdriver  OVM Driver
	class ${1:ovc_name}_driver extends ovm_driver #(${2:ovc_item});
	   ${4}
	   string tID;
	   virtual interface ${3:ovc_if} vif;
	   $2 item;
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   \`ovm_component_utils_begin($1_driver)
	      \`ovm_field_object(item, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task get_and_drive();
	      forever
		begin
		   // wait(vif.reset==0);  // block until reset released
		   seq_item_port.get_next_item(item);
		   send_to_dut(item);
		   seq_item_port.item_done();
		end
	   endtask: get_and_drive
	
	   task send_to_dut(input $2 item);
	      ovm_report_info(tID, $psprintf("%s : item sent is %0s",
					     tID, item.sprint()), OVM_FULL);
	      // Send data to DUT (BFM - fill in your BFM code here)
	      #10 ;
	      #10 ;
	   endtask: send_to_dut
	
	   task reset_dut();
	      // fill in any reset code here
	   endtask: reset_dut
	
	   task run();
	      ovm_report_info(tID, $psprintf(" %s : running", tID), OVM_MEDIUM);
	      // reset_dut(); // fill in 'reset_dut()' if needed
	      get_and_drive();
	   endtask: run
	
	   virtual function void report();
	      // fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	endclass: $1_driver
snippet ovm  OVM Env
	class ${1:ovc_name}_env extends ovm_env;
	   ${2}
	   $1_agent agent0;
	   \`ovm_component_utils($1_env)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      agent0 = $1_agent::type_id::create("agent0", this);
	   endfunction: build
	
	endclass: $1_env
snippet ovm_env  OVM Env
	class ${1:ovc_name}_env extends ovm_env;
	   ${2}
	   $1_agent agent0;
	   \`ovm_component_utils($1_env)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      agent0 = $1_agent::type_id::create("agent0", this);
	   endfunction: build
	
	endclass: $1_env
snippet ovmenv  OVM Env
	class ${1:ovc_name}_env extends ovm_env;
	   ${2}
	   $1_agent agent0;
	   \`ovm_component_utils($1_env)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      agent0 = $1_agent::type_id::create("agent0", this);
	   endfunction: build
	
	endclass: $1_env
snippet ovm  OVM Interface
	interface $1(input logic clock, input logic reset);
	
	   // ToDo: Declare the interface signals corresponding to the ports
	   ${2}
	   wire [7:0] sync_tx;
	   wire [7:0] sync_rx;
	
	   logic async_sig;
	   
	   // ToDo: Define clocking blocks
	   // -- use the 'clocking' snippet
	   
	   // ToDo: Define a modport for each interface perspective
	   // -- use the 'modport' snippet
	
	endinterface: $1
snippet interface  OVM Interface
	interface $1(input logic clock, input logic reset);
	
	   // ToDo: Declare the interface signals corresponding to the ports
	   ${2}
	   wire [7:0] sync_tx;
	   wire [7:0] sync_rx;
	
	   logic async_sig;
	   
	   // ToDo: Define clocking blocks
	   // -- use the 'clocking' snippet
	   
	   // ToDo: Define a modport for each interface perspective
	   // -- use the 'modport' snippet
	
	endinterface: $1
snippet ovm  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovm_monitor  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovm_mon  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovmmon  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovmmonitor  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovm  OVM Seq Lib
	class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`ovm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in ovm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(OVM_LOW, ("RUNNING sequence: %s", get_name()))
	      ovm_report_info(tID, $psprintf("%s: sequence Running", tID), OVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(OVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      ovm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), OVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(OVM_LOW, ("sequence: %s complete", get_name()))
	      ovm_report_info(tID, $psprintf("sequence: %s complete", tID), OVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet ovm_seq_lib  OVM Seq Lib
	class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`ovm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in ovm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(OVM_LOW, ("RUNNING sequence: %s", get_name()))
	      ovm_report_info(tID, $psprintf("%s: sequence Running", tID), OVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(OVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      ovm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), OVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(OVM_LOW, ("sequence: %s complete", get_name()))
	      ovm_report_info(tID, $psprintf("sequence: %s complete", tID), OVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet ovm_seqlib  OVM Seq Lib
	class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`ovm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in ovm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(OVM_LOW, ("RUNNING sequence: %s", get_name()))
	      ovm_report_info(tID, $psprintf("%s: sequence Running", tID), OVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(OVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      ovm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), OVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(OVM_LOW, ("sequence: %s complete", get_name()))
	      ovm_report_info(tID, $psprintf("sequence: %s complete", tID), OVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet ovmseqlib  OVM Seq Lib
	class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`ovm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in ovm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(OVM_LOW, ("RUNNING sequence: %s", get_name()))
	      ovm_report_info(tID, $psprintf("%s: sequence Running", tID), OVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(OVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      ovm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), OVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(OVM_LOW, ("sequence: %s complete", get_name()))
	      ovm_report_info(tID, $psprintf("sequence: %s complete", tID), OVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet ovm  OVM Sequencer
	class ${1:ovc_name}_sequencer extends ovm_sequencer #(${2:ovc_item});
	   ${3}
	   \`ovm_sequencer_utils($1_sequencer)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      \`ovm_update_sequence_lib_and_item($2)
	   endfunction: new
	
	endclass: $1_sequencer
snippet ovm_sequencer  OVM Sequencer
	class ${1:ovc_name}_sequencer extends ovm_sequencer #(${2:ovc_item});
	   ${3}
	   \`ovm_sequencer_utils($1_sequencer)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      \`ovm_update_sequence_lib_and_item($2)
	   endfunction: new
	
	endclass: $1_sequencer
snippet ovmsequencer  OVM Sequencer
	class ${1:ovc_name}_sequencer extends ovm_sequencer #(${2:ovc_item});
	   ${3}
	   \`ovm_sequencer_utils($1_sequencer)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      \`ovm_update_sequence_lib_and_item($2)
	   endfunction: new
	
	endclass: $1_sequencer
snippet ovm  OVM Sve
	class sve extends ovm_env;
	   ${2}
	   ${1:ovc_name}_env env0;
	   \`ovm_component_utils(sve)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      env0 = $1_env::type_id::create("env0", this);
	   endfunction: build
	
	   virtual function void connect();
	      env0.agent0.assign_vif(top.if0);
	   endfunction: connect
	endclass: sve
snippet ovm_sve  OVM Sve
	class sve extends ovm_env;
	   ${2}
	   ${1:ovc_name}_env env0;
	   \`ovm_component_utils(sve)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      env0 = $1_env::type_id::create("env0", this);
	   endfunction: build
	
	   virtual function void connect();
	      env0.agent0.assign_vif(top.if0);
	   endfunction: connect
	endclass: sve
snippet ovmsve  OVM Sve
	class sve extends ovm_env;
	   ${2}
	   ${1:ovc_name}_env env0;
	   \`ovm_component_utils(sve)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      env0 = $1_env::type_id::create("env0", this);
	   endfunction: build
	
	   virtual function void connect();
	      env0.agent0.assign_vif(top.if0);
	   endfunction: connect
	endclass: sve
snippet ovm  OVM Test
	class test1 extends ovm_test;
	   ${2}
	   sve sve0;
	   \`ovm_component_utils(test1)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      set_config_int("sve0.env0.agent0.sequencer", "count", 2);
	      set_config_int("sve0.env0.agent0", "is_active", OVM_ACTIVE);
	      set_config_string("sve0.env0.agent0.sequencer",
				"default_sequence", "${1:ovc_name}_seq1");
	      sve0 = sve::type_id::create("sve0", this);
	   endfunction: build
	
	   task run();
	      \`message(OVM_LOW, ("test1 running..."))
	      ovm_top.print_topology();
	      #10000
		//delay is simple "end of test" mechanism
		//use objections in sequences for better "end of test" detection
		\`message(OVM_LOW, ("User activated end of simulation"))
	      global_stop_request();
	   endtask: run
	
	endclass: test1
snippet ovm_test  OVM Test
	class test1 extends ovm_test;
	   ${2}
	   sve sve0;
	   \`ovm_component_utils(test1)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      set_config_int("sve0.env0.agent0.sequencer", "count", 2);
	      set_config_int("sve0.env0.agent0", "is_active", OVM_ACTIVE);
	      set_config_string("sve0.env0.agent0.sequencer",
				"default_sequence", "${1:ovc_name}_seq1");
	      sve0 = sve::type_id::create("sve0", this);
	   endfunction: build
	
	   task run();
	      \`message(OVM_LOW, ("test1 running..."))
	      ovm_top.print_topology();
	      #10000
		//delay is simple "end of test" mechanism
		//use objections in sequences for better "end of test" detection
		\`message(OVM_LOW, ("User activated end of simulation"))
	      global_stop_request();
	   endtask: run
	
	endclass: test1
snippet ovmtest  OVM Test
	class test1 extends ovm_test;
	   ${2}
	   sve sve0;
	   \`ovm_component_utils(test1)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      set_config_int("sve0.env0.agent0.sequencer", "count", 2);
	      set_config_int("sve0.env0.agent0", "is_active", OVM_ACTIVE);
	      set_config_string("sve0.env0.agent0.sequencer",
				"default_sequence", "${1:ovc_name}_seq1");
	      sve0 = sve::type_id::create("sve0", this);
	   endfunction: build
	
	   task run();
	      \`message(OVM_LOW, ("test1 running..."))
	      ovm_top.print_topology();
	      #10000
		//delay is simple "end of test" mechanism
		//use objections in sequences for better "end of test" detection
		\`message(OVM_LOW, ("User activated end of simulation"))
	      global_stop_request();
	   endtask: run
	
	endclass: test1
snippet ovm  OVM Top
	\`include "ovm.svh"
	\`include "${1:ovc_name}_inc.svh"
	\`include "sve.sv"
	\`include "test1.sv"
	module top();
	   ${3}
	   logic clock;
	   logic reset;
	
	   ${2:ovc_if} if0(clock, reset); // instantiate ovc interface
	
	   initial
	     begin
		run_test();
	     end
	
	   always #10 clock = ~clock;
	
	   initial
	     begin
		clock = 0;
		reset = 1; // active high reset for this example
		#75 reset = 0;
	     end
	
	   // instantiate and connect dut to interface(s) here
	
	endmodule: top
snippet ovm_top  OVM Top
	\`include "ovm.svh"
	\`include "${1:ovc_name}_inc.svh"
	\`include "sve.sv"
	\`include "test1.sv"
	module top();
	   ${3}
	   logic clock;
	   logic reset;
	
	   ${2:ovc_if} if0(clock, reset); // instantiate ovc interface
	
	   initial
	     begin
		run_test();
	     end
	
	   always #10 clock = ~clock;
	
	   initial
	     begin
		clock = 0;
		reset = 1; // active high reset for this example
		#75 reset = 0;
	     end
	
	   // instantiate and connect dut to interface(s) here
	
	endmodule: top
snippet ovmtop  OVM Top
	\`include "ovm.svh"
	\`include "${1:ovc_name}_inc.svh"
	\`include "sve.sv"
	\`include "test1.sv"
	module top();
	   ${3}
	   logic clock;
	   logic reset;
	
	   ${2:ovc_if} if0(clock, reset); // instantiate ovc interface
	
	   initial
	     begin
		run_test();
	     end
	
	   always #10 clock = ~clock;
	
	   initial
	     begin
		clock = 0;
		reset = 1; // active high reset for this example
		#75 reset = 0;
	     end
	
	   // instantiate and connect dut to interface(s) here
	
	endmodule: top
snippet package  package .. endpackage
	package ${1:package_name};
	  ${2}
	endpackage: $1
snippet parameter  parameter .. 
	parameter ${1:param_name} = ${2:param_value};
	${3}
snippet program  program .. { .. }
	program automatic ${1:name};
	   // declarations
	   ${2}
	
	   initial begin
	
	   end
	endprogram: $1
snippet rand  rand ... { ... }
	snippet rand
	rand ${1:type} ${2:name};
	
	constraint $2_cst {
	   // define constraint here using dist, inside, = etc
	   ${3}
	};
snippet randcase  randcase ..
	   ${1:weight1}:
	      ${3}
	   ${2:weight2}:
	endcase
snippet repeat  repeat(N) ..
	repeat(${1:N}) begin
	   ${2}
	end
snippet struct  struct ... { ... }
	typedef struct {
	   ${2}
	   } ${1:name_s};
snippet task  task .. endtask
	task ${1:task_name} ($3);
	  ${2}
	endtask: $1
snippet typedef  typedef ..
	typedef ${1:type} ${2:type_name};
	${3}
snippet union  union ... { ... }
	typedef union {
	   ${2}
	} ${1:name_u};
snippet vmm  VMM Atomic Gen (VMM version 1.1.1)
	// ${1:XACTN} -- Name of the transaction descriptor class
	// ${2:#(int DW=32, int AW=32)} -- Transaction Descriptor Class Parameters
	// ${3:#(DW, AW)} -- Parameter Instance
	// ${4:GEN} -- Name of the Atomic generator being defined
	${5}
	typedef class $4;
	
	class $4_callbacks $2 extends vmm_xactor_callbacks;
	   typedef $4 $3 transactor_type;
	   typedef $1 $3 transaction_type;
	
	   virtual task post_inst_gen(transactor_type gen,
				      transaction_type obj,
				      ref bit drop);
	   endtask: post_inst_gen
	endclass: $4_callbacks
	
	
	class $4 $2 extends vmm_xactor;
	   // some typedefs to ease up parameters usage
	   typedef $4_callbacks $3 callback_type;
	   typedef $1 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	
	   int unsigned stop_after_n_insts;
	
	   typedef enum int {GENERATED,
			     DONE} symbols_e;
	
	
	   transaction_type randomized_obj;
	
	   channel_type out_chan;
	
	   local int scenario_count;
	   local int obj_count;
	
	   virtual function string psdisplay(string prefix = "");
	      psdisplay = super.psdisplay(prefix);
	      $sformat(psdisplay, "%s [stops after #insts %0d>%0d]",
		       psdisplay, this.obj_count, this.stop_after_n_insts);
	      $sformat(psdisplay, "%s\n%sOutChan: %s(%s) [level=%0d of %0d]",
		       psdisplay, prefix, this.out_chan.log.get_name(),
		       this.out_chan.log.get_instance(), this.out_chan.level(),
		       this.out_chan.full_level());
	      if (this.randomized_obj != null) begin
		 prefix = {prefix, "Factory: "};
		 psdisplay = {psdisplay, "\n",
			      this.randomized_obj.psdisplay(prefix)};
	      end
	      return psdisplay;
	   endfunction: psdisplay
	
	   function new(string inst,
			int stream_id = -1,
			channel_type out_chan  = null);
	      super.new("$1 Atomic Generator", inst, stream_id);
	
	      if (out_chan == null) begin
		 out_chan = new("$1 Atomic Generator output channel",
				inst);
		 // \`VMM_OBJECT_SET_PARENT(out_chan, this)
	      end
	      this.out_chan = out_chan;
	      this.out_chan.set_producer(this);
	      this.log.is_above(this.out_chan.log);
	
	      this.scenario_count = 0;
	      this.obj_count = 0;
	      this.stop_after_n_insts = 0;
	
	      void'(this.notify.configure(GENERATED, vmm_notify::ONE_SHOT));
	      void'(this.notify.configure(DONE, vmm_notify::ON_OFF));
	
	      this.randomized_obj = new;
	      // \`VMM_OBJECT_SET_PARENT(this.randomized_obj, this)
	   endfunction: new
	
	   virtual task inject(transaction_type obj,
			       ref bit dropped);
	      dropped = 0;
	
	      \`vmm_callback(callback_type,
			     post_inst_gen(this, obj, dropped));
	
	      if (!dropped) begin
		 this.obj_count++;
		 this.notify.indicate(GENERATED, obj);
		 this.out_chan.put(obj);
	      end
	   endtask: inject
	
	   virtual function void reset_xactor(vmm_xactor::reset_e rst_typ = SOFT_RST);
	      super.reset_xactor(rst_typ);
	
	      this.out_chan.flush();
	      this.scenario_count = 0;
	      this.obj_count = 0;
	
	      if (rst_typ >= FIRM_RST) begin
		 this.notify.reset( , vmm_notify::HARD);
	      end
	
	      if (rst_typ >= HARD_RST) begin
		 this.stop_after_n_insts = 0;
		 this.randomized_obj     = new;
	      end
	   endfunction: reset_xactor
	
	   virtual protected task main();
	      bit dropped;
	
	      fork
		 super.main();
	      join_none
	
	      while (this.stop_after_n_insts <= 0 ||
		     this.obj_count < this.stop_after_n_insts) begin
	
		 this.wait_if_stopped();
	
		 this.randomized_obj.stream_id   = this.stream_id;
		 this.randomized_obj.scenario_id = this.scenario_count;
		 this.randomized_obj.data_id     = this.obj_count;
	
		 if (!this.randomized_obj.randomize()) begin
		    \`vmm_fatal(this.log, "Cannot randomize atomic instance");
		    continue;
		 end
	
		 begin
		    transaction_type obj;
	
		    $cast(obj, this.randomized_obj.copy());
		    // \`VMM_OBJECT_SET_PARENT(obj, this)
		    this.inject(obj, dropped);
		 end
	      end
	
	      this.notify.indicate(DONE);
	      this.notify.indicate(XACTOR_STOPPED);
	      this.notify.indicate(XACTOR_IDLE);
	      this.notify.reset(XACTOR_BUSY);
	      this.scenario_count++;
	   endtask: main
	
	endclass: $4
snippet vmm  VMM Env
	class ${1:name}_env extends vmm_env;
	   // Instantiate cmd Transactors, Monitors, Configurations, Channels,
	   // and Log format controls
	   ${2}
	   // Command transactors
	   $1_cmd_xactor cmd_xactor_0;
	   // Vmm Channels
	   $1_xactn_channel gen_chan_0, mon_chan_0;
	   // Configuration
	   $1_cfg test_cfg_0;
	   // Xactn Generators
	   $1_xactn_atomic_gen xactn_gen_0;
	   // Monitors
	   $1_mon_xactor mon_0;
	   // Format Controls
	   $1_log_fmt log_fmt_cntl;
	
	   function new();              // for environment
	      super.new();
	      $timeformat(-9,2, " ns");
	      this.test_cfg_0 = new();
	      log_fmt_cntl = new();
	      log.set_format(log_fmt_cntl);
	   endfunction: new
	
	   // These tasks are mandated by VMM
	   extern function void gen_cfg();
	   extern function void build();
	   extern task reset_dut();
	   extern task start();
	   extern task run();
	   extern task wait_for_end();
	   extern task stop();
	   extern task report();
	endclass: $1_env
	
	function void $1_env::gen_cfg();
	   super.gen_cfg();
	   this.test_cfg_0.randomize();
	endfunction: gen_cfg
	
	function void $1_env::build();
	   string msg;
	   super.build();
	   // Instantiation of channel
	   this.gen_chan_0 = new("$1_chan","channel");
	   this.response_chan_0 = new("$1_response_channel", "channel");
	   // Instantiation of command-layer transactor
	   this.cmd_xactor_0 = new("cmd_xactor",
				   0,
				   \`TOP.f_if,
				   $1_channel_0,
				   $1_response_chan0
				   );
	   // Instantiation of transaction generator
	   this.xactn_gen_0 = new ("$1_gen", 0, $1_channel_0);
	   this.xactn_gen_0.stop_after_n_insts = this.test_cfg_0.no_of_xactions;
	   // Setting up a message, then send it
	   $sformat(msg, "Sim shall run for no_of_xactions %0d ",
		    this.xactn_gen_0.stop_after_n_insts);
	   \`vmm_note(log, msg);
	   // Instantiation of monitor channel
	   this.mon_chan_0 = new("$1_mon_chan_0","channel");
	   // Instantiation of monitor
	   this.mon_0 = new("$1 Mon", 0, \`TOP.f_if,
			    this.$1_mon_chan_0);
	
	endfunction: build
	
	
	
	task $1_env::reset_dut();
	   super.reset_dut();
	   // Code to reset the DUT to be kept here
	endtask: reset_dut
	
	task $1_env::run();
	   super.run();
	endtask: run
	
	task $1_env::start();
	   // May use factory patterns
	   $1_xactn injection_xactn;
	   bit dropped;
	   injection_xactn=new;
	   super.start();
	   //this.xactn_gen_0.start_xactor();
	   this.cmd_xactor_0.start_xactor();
	   this.mon_0.start_xactor();
	   this.mon_chan_0.sink(); // flush content of channel
	   \`vmm_note(log, "Start of Inject");
	   for (int i = 0; i < 15; i++) begin
	      dropped = 0;
	      injection_xactn.randomize() with
		{data < 5; kind==PUSH;};
	      this.xactn_gen_0.inject(injection_xactn, dropped);
	   end
	   \`vmm_note(log, "End of Inject, start of gen0 xactor");
	   this.xactn_gen_0.start_xactor();
	
	   //
	endtask: start
	
	task $1_env::wait_for_end();
	   super.wait_for_end();
	   this.xactn_gen_0.notify.wait_for($1_xactn_atomic_gen::DONE);
	endtask: wait_for_end
	
	task $1_env::stop();
	   super.stop();
	   $finish;
	endtask: stop
	
	
	task $1_env:: report();
	   super.report();
	   \`vmm_note(log, "This is where additional model info is displayed");
	   \`vmm_note(log, "**** REPORT ***");
	endtask: report
snippet vmm  VMM Full-Duplex Functional Driver (vmmgen)
	//
	// Template for VMM-compliant full-duplex functional-level transactor
	//
	// ${1:XACT}       Name of transactor
	// ${2:#(int DW=32, int AW=32)} Parameters
	// ${3:#(DW, AW)}  Parameter Instance
	// ${4:TR}         Name of high-level transaction descriptor class
	// ${5:TX}         Name of low-level transaction descriptor class
	
	\`include "vmm.sv"
	\`include "$4.sv"
	\`include "$5.sv"
	
	typedef class $1;
	
	class $1_callbacks $2 extends vmm_xactor_callbacks;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transactor_type;
	   typedef $4 $3 hi_transaction_type;
	   typedef $5 $3 lo_transaction_type;
	
	   ${6}
	   // ToDo: Add additional relevant callbacks
	   // ToDo: Use a task if callbacks can be blocking
	
	   // Called before a transaction is executed
	   virtual task pre_trans(transactor_type xactor,
	                          hi_transaction_type tr,
	                          bit drop);
	   endtask: pre_trans
	
	   virtual function void pre_trans_exec(transactor_type xactor,
	                                        hi_transaction_type tr,
	                                        lo_transaction_type tx[$]);
	   endfunction: pre_trans_exec
	
	   // Called at start of lower transaction
	   virtual task pre_exec(transactor_type xactor,
	                         lo_transaction_type tx,
	                         bit drop);
	   endtask: pre_exec
	
	   // Called at end of lower transaction
	   virtual task post_exec(transactor_type xactor,
	                          lo_transaction_type tx);
	   endtask: post_exec
	
	   virtual function void post_trans_exec(transactor_type xactor,
	                                         hi_transaction_type tr,
	                                         lo_transaction_type tx[$]);
	   endfunction: post_trans_exec
	
	   // Called after a transaction has been executed
	   virtual task post_in_trans(transactor_type xactor,
	                              hi_transaction_type tr);
	   endtask: post_in_trans
	
	   // Called at end of observed lower-level transaction
	   virtual function void post_trans_obs(transactor_type xactor,
	                                        lo_transaction_type tx,
	                                        bit drop);
	   endfunction: post_trans_obs
	
	   // Call when a high-level transaction has been identified
	   virtual function void post_out_trans(transactor_type xactor,
	                                        lo_transaction_type tx[$],
	                                        hi_transaction_type tr,
	                                        bit drop);
	   endfunction: post_out_trans
	endclass: $1_callbacks
	
	
	class $1_cfg;
	   // ToDo: Add transactor configuration class properties
	   rand int mode;
	endclass: $1_cfg
	
	
	class $1 $2 extends vmm_xactor;
	   typedef $1_callbacks $3 callback_type;
	   typedef $4 $3 hi_transaction_type;
	   typedef $5 $3 lo_transaction_type;
	   typedef vmm_channel_typed #(hi_transaction_type) hi_channel_type;
	   typedef vmm_channel_typed #(lo_transaction_type) lo_channel_type;
	   typedef $1_cfg configuration_type;
	
	   int EXECUTING;
	   int SUB_EXECUTING;
	   int OBSERVED;
	   int SUB_OBSERVED;
	
	
	   protected configuration_type cfg;
	   local     configuration_type reset_cfg;
	   protected hi_transaction_type rx_factory;
	   local     hi_transaction_type reset_rx_factory;
	
	   hi_channel_type in_chan;
	   hi_channel_type out_chan;
	   lo_channel_type exec_chan;
	   lo_channel_type obs_chan;
	
	   extern function new (string inst,
	                        int stream_id,
	                        configuration_type cfg = null,
	                        hi_channel_type in_chan = null,
	                        hi_channel_type out_chan = null,
	                        lo_channel_type exec_chan = null,
	                        lo_channel_type obs_chan = null,
	                        hi_transaction_type rx_factory = null);
	
	   extern virtual function void reconfigure(configuration_type cfg);
	   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);
	   extern protected virtual task main();
	   extern protected virtual task tx_driver();
	   extern protected virtual task rx_monitor();
	
	endclass: $1
	
	
	function $1::new(string inst,
	                 int stream_id,
	                 configuration_type cfg,
	                 hi_channel_type in_chan,
	                 hi_channel_type out_chan,
	                 lo_channel_type exec_chan,
	                 lo_channel_type obs_chan,
	                 hi_transaction_type rx_factory);
	
	   super.new("$1 Transactor", inst, stream_id);
	
	   this.EXECUTING     = this.notify.configure(-1, vmm_notify::ON_OFF);
	   this.SUB_EXECUTING = this.notify.configure(-1, vmm_notify::ON_OFF);
	   this.OBSERVED      = this.notify.configure();
	   this.SUB_OBSERVED  = this.notify.configure();
	
	   if (cfg == null) cfg = new;
	   this.cfg = cfg;
	   this.reset_cfg = cfg;
	
	   if (in_chan == null) in_chan = new("$1 Input Channel", inst);
	   this.in_chan = in_chan;
	   if (out_chan == null) out_chan = new("$1 Output Channel", inst);
	   this.out_chan = out_chan;
	   if (exec_chan == null) exec_chan = new("$1 Execution Channel", inst);
	   this.exec_chan = exec_chan;
	   if (obs_chan == null) obs_chan = new("$1 Observation Channel", inst);
	   this.obs_chan = obs_chan;
	
	   if (rx_factory == null) rx_factory = new;
	   this.rx_factory = rx_factory;
	   this.reset_rx_factory = rx_factory;
	endfunction: new
	
	
	function void $1::reconfigure(configuration_type cfg);
	
	   if (!this.notify.is_on(XACTOR_IDLE)) begin
	      \`vmm_warning(this.log,
	                    "Transactor should be reconfigured only when IDLE");
	   end
	
	   this.cfg = cfg;
	
	   // ToDo: Notify any running threads of the new configuration
	endfunction: reconfigure
	
	
	function void $1::reset_xactor(reset_e rst_typ);
	
	   super.reset_xactor(rst_typ);
	
	   this.in_chan.flush();
	   this.out_chan.flush();
	   this.exec_chan.flush();
	   this.obs_chan.flush();
	
	   // ToDo: Reset other state information
	
	   if (rst_typ != SOFT_RST) begin
	      // ToDo: Reset state if FIRM or above
	   end
	
	   if (rst_typ == PROTOCOL_RST) begin
	      // ToDo: Reset state if PROTOCOL
	   end
	
	   if (rst_typ == HARD_RST) begin
	      // ToDo: Reset state if HARD or above
	      this.cfg = this.reset_cfg;
	      this.rx_factory = this.reset_rx_factory;
	   end
	endfunction: reset_xactor
	
	
	task $1::main();
	   super.main();
	
	   fork
	      tx_driver();
	      rx_monitor();
	   join
	endtask: main
	
	
	task $1::tx_driver();
	
	   forever begin
	      hi_transaction_type tr;
	      lo_transaction_type tx[$];
	      bit drop;
	
	      this.wait_if_stopped_or_empty(this.in_chan);
	      this.in_chan.activate(tr);
	
	      drop = 0;
	      \`vmm_callback(callback_type,
	                     pre_trans(this, tr, drop));
	      if (drop) begin
	         void'(this.in_chan.remove());
	         continue;
	      end
	
	      void'(this.in_chan.start());
	      this.notify.indicate(this.EXECUTING, tr);
	
	      \`vmm_trace(this.log, "Starting transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      // ToDo: Turn high-level transaction into a series of
	      //       low-level transactions
	
	      \`vmm_callback(callback_type,
	                     pre_trans_exec(this, tr, tx));
	
	      foreach (tx[i]) begin
	         drop = 0;
	         \`vmm_callback(callback_type,
				pre_exec(this, tx[i], drop));
	         if (drop) continue;
	
	         this.notify.indicate(this.SUB_EXECUTING, tx[i]);
	
	         \`vmm_debug(this.log, "Executing lower-level transaction...");
	         \`vmm_verbose(this.log, tx[i].psdisplay("   "));
	
	         this.exec_chan.put(tx[i]);
	
	         // ToDo: Add completion model if not blocking
	
	         this.notify.reset(this.SUB_EXECUTING);
	
	         \`vmm_debug(this.log, "Executed lower-level transaction...");
	         \`vmm_verbose(this.log, tx[i].psdisplay("   "));
	
	         \`vmm_callback(callback_type,
				post_exec(this, tx[i]));
	      end // foreach (tx[i])
	
	      \`vmm_callback(callback_type,
	                     post_trans_exec(this, tr, tx));
	
	      // ToDo: Determine result of high-level transaction from the
	      //       results of the low-level transactions
	
	      this.notify.reset(this.EXECUTING);
	      void'(this.in_chan.complete());
	
	      \`vmm_trace(this.log, "Completed transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      \`vmm_callback(callback_type,
	                     post_in_trans(this, tr));
	
	      void'(this.in_chan.remove());
	   end
	endtask: tx_driver
	
	
	task $1::rx_monitor();
	
	   forever begin
	      hi_transaction_type tr;
	      lo_transaction_type tx[$];
	      lo_transaction_type tmp_tx;
	      bit drop;
	
	      tr = null;
	
	      this.wait_if_stopped_or_empty(this.obs_chan);
	      this.obs_chan.get(tmp_tx);
	      tx.push_back(tmp_tx);
	
	      drop = 0;
	      \`vmm_callback(callback_type,
	                    post_trans_obs(this, tx[tx.size()-1], drop));
	      if (drop) begin
	         tx.pop_back();
	         continue;
	      end
	
	      this.notify.indicate(this.SUB_OBSERVED, tx[tx.size()-1]);
	
	      \`vmm_debug(this.log, "Observed lower-level transaction...");
	      \`vmm_verbose(this.log, tx[tx.size()-1].psdisplay("   "));
	
	      // ToDo: Check if the lower-level transactions observed so far
	      //       create a higher-level transaction
	
	      $cast(tr, this.rx_factory.copy());
	
	      if (tr != null) begin
	         drop = 0;
	
	         \`vmm_callback(callback_type,
	                       post_out_trans(this, tx, tr, drop));
	
	         if (!drop) begin
	            this.notify.indicate(this.OBSERVED, tr);
	
	            \`vmm_trace(this.log, "Observed transaction...");
	            \`vmm_debug(this.log, tr.psdisplay("   "));
	
	            this.out_chan.sneak(tr);
	         end
	
	         // ToDo: removed the interpreted observed sub transactions
	         tx.delete();
	      end
	   end
	endtask: rx_monitor
snippet vmm  VMM Full-Duplex Functional Monitor (vmmgen)
	//
	// Template for VMM-compliant full-duplex functional-level monitor
	//
	// ${1:XACT}       Name of transactor
	// ${2:#(int DW=32, int AW=32)} Parameters
	// ${3:#(DW, AW)}  Parameter Instance
	// ${4:TR}         Name of high-level transaction descriptor class
	// ${5:TX}         Name of low-level transaction descriptor class
	
	\`include "vmm.sv"
	\`include "$4.sv"
	\`include "$5.sv"
	
	typedef class $1;
	
	class $1_callbacks $2 extends vmm_xactor_callbacks;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transactor_type;
	   typedef $4 $3 hi_transaction_type;
	   typedef $5 $3 lo_transaction_type;
	
	   ${6}
	   // ToDo: Add additional relevant callbacks
	   // ToDo: Use a task if callbacks can be blocking
	
	   // Called at end of observed lower-level transaction
	   virtual function void post_tx_trans_obs(transactor_type xactor,
	                                           lo_transaction_type tx,
	                                           bit drop);
	   endfunction: post_tx_trans_obs
	   virtual function void post_rx_trans_obs(transactor_type xactor,
	                                           lo_transaction_type tx,
	                                           bit drop);
	   endfunction: post_rx_trans_obs
	 
	   // Call when a high-level transaction has been identified
	   virtual function void post_tx_trans(transactor_type xactor,
	                                       lo_transaction_type tx[$],
	                                       hi_transaction_type tr,
	                                       bit drop);
	   endfunction: post_tx_trans
	   virtual function void post_rx_trans(transactor_type xactor,
	                                       lo_transaction_type tx[$],
	                                       hi_transaction_type tr,
	                                       bit drop);
	   endfunction: post_rx_trans
	endclass: $1_callbacks
	
	
	class $1_cfg;
	   // ToDo: Add transactor configuration class properties
	   rand int mode;
	endclass: $1_cfg
	
	
	class $1 $2 extends vmm_xactor;
	
	   typedef $1_callbacks $3 callback_type;
	   typedef $4 $3 hi_transaction_type;
	   typedef $5 $3 lo_transaction_type;
	   typedef vmm_channel_typed #(hi_transaction_type) hi_channel_type;
	   typedef vmm_channel_typed #(lo_transaction_type) lo_channel_type;
	   typedef $1_cfg configuration_type;
	
	   int OBS_TX;
	   int SUB_OBS_TX;
	   int OBS_RX;
	   int SUB_OBS_RX;
	
	   protected configuration_type cfg;
	   local     configuration_type reset_cfg;
	   protected hi_transaction_type tx_factory;
	   local     hi_transaction_type reset_tx_factory;
	   protected hi_transaction_type rx_factory;
	   local     hi_transaction_type reset_rx_factory;
	
	   hi_channel_type tx_chan;
	   hi_channel_type rx_chan;
	   lo_channel_type tx_obs_chan;
	   lo_channel_type rx_obs_chan;
	
	   extern function new (string inst,
				int stream_id,
				configuration_type cfg = null,
				hi_channel_type tx_chan = null,
				hi_channel_type rx_chan = null,
				lo_channel_type tx_obs_chan = null,
				lo_channel_type rx_obs_chan = null,
				hi_transaction_type tx_factory = null,
				hi_transaction_type rx_factory = null);
	
	   extern virtual function void reconfigure(configuration_type cfg);
	   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);
	   extern protected virtual task main();
	   extern protected virtual task tx_monitor();
	   extern protected virtual task rx_monitor();
	
	endclass: $1
	
	
	function $1::new(string inst,
	                   int stream_id,
	                   configuration_type cfg,
	                   hi_channel_type tx_chan,
	                   hi_channel_type rx_chan,
	                   lo_channel_type tx_obs_chan,
	                   lo_channel_type rx_obs_chan,
	                   hi_transaction_type tx_factory,
	                   hi_transaction_type rx_factory);
	
	   super.new("$1 Transactor", inst, stream_id);
	
	   this.OBS_TX     = this.notify.configure();
	   this.SUB_OBS_TX = this.notify.configure();
	   this.OBS_RX     = this.notify.configure();
	   this.SUB_OBS_RX = this.notify.configure();
	
	   if (cfg == null) cfg = new;
	   this.cfg = cfg;
	   this.reset_cfg = cfg;
	
	   if (tx_chan == null) tx_chan = new("$1 Tx Output Channel", inst);
	   this.tx_chan = tx_chan;
	   if (rx_chan == null) rx_chan = new("$1 Rx Output Channel", inst);
	   this.rx_chan = rx_chan;
	   if (tx_obs_chan == null)
	     tx_obs_chan = new("$1 Tx Observation Channel", inst);
	   this.tx_obs_chan = tx_obs_chan;
	   if (rx_obs_chan == null)
	     rx_obs_chan = new("$1 Rx Observation Channel", inst);
	   this.rx_obs_chan = rx_obs_chan;
	
	   if (tx_factory == null) tx_factory = new;
	   this.tx_factory = tx_factory;
	   this.reset_tx_factory = tx_factory;
	   if (rx_factory == null) rx_factory = new;
	   this.rx_factory = rx_factory;
	   this.reset_rx_factory = rx_factory;
	endfunction: new
	
	
	function void $1::reconfigure(configuration_type cfg);
	
	   if (!this.notify.is_on(XACTOR_IDLE)) begin
	      \`vmm_warning(this.log,
	                   "Transactor should be reconfigured only when IDLE");
	   end
	
	   this.cfg = cfg;
	
	   // ToDo: Notify any running threads of the new configuration
	endfunction: reconfigure
	
	
	function void $1::reset_xactor(reset_e rst_typ);
	
	   super.reset_xactor(rst_typ);
	
	   this.tx_chan.flush();
	   this.rx_chan.flush();
	   this.tx_obs_chan.flush();
	   this.rx_obs_chan.flush();
	
	   // ToDo: Reset other state information
	
	   if (rst_typ != SOFT_RST) begin
	      // ToDo: Reset state if FIRM or above
	   end
	
	   if (rst_typ == PROTOCOL_RST) begin
	      // ToDo: Reset state if PROTOCOL
	   end
	
	   if (rst_typ == HARD_RST) begin
	      // ToDo: Reset state if HARD or above
	      this.cfg = this.reset_cfg;
	      this.tx_factory = this.reset_tx_factory;
	      this.rx_factory = this.reset_rx_factory;
	   end
	endfunction: reset_xactor
	
	
	task $1::main();
	   super.main();
	
	   fork
	      tx_monitor();
	      rx_monitor();
	   join
	endtask: main
	
	
	task $1::tx_monitor();
	
	   forever begin
	      hi_transaction_type tr;
	      lo_transaction_type tx[$];
	      lo_transaction_type tmp_tx;
	      bit drop;
	
	      tr = null;
	
	      this.wait_if_stopped_or_empty(this.tx_obs_chan);
	      this.tx_obs_chan.get(tmp_tx);
	      tx.push_back(tmp_tx);
	
	      drop = 0;
	      \`vmm_callback(callback_type,
	                    post_tx_trans_obs(this, tx[tx.size()-1], drop));
	      if (drop) begin
	         tx.pop_back();
	         continue;
	      end
	
	      this.notify.indicate(this.SUB_OBS_TX, tx[tx.size()-1]);
	
	      \`vmm_debug(this.log, "Observed lower-level Tx transaction...");
	      \`vmm_verbose(this.log, tx[tx.size()-1].psdisplay("   "));
	
	      // ToDo: Check if the lower-level transactions observed so far
	      //       create a higher-level transaction
	
	      $cast(tr, this.tx_factory.copy());
	
	      if (tr != null) begin
	         drop = 0;
	
	         \`vmm_callback(callback_type,
	                       post_tx_trans(this, tx, tr, drop));
	
	         if (!drop) begin
	            this.notify.indicate(this.OBS_TX, tr);
	
	            \`vmm_trace(this.log, "Observed transaction...");
	            \`vmm_debug(this.log, tr.psdisplay("   "));
	
	            this.tx_chan.sneak(tr);
	         end
	
	         // ToDo: removed the interpreted observed sub transactions
	         tx.delete();
	      end
	   end
	endtask: tx_monitor
	
	
	task $1::rx_monitor();
	
	   forever begin
	      hi_transaction_type tr;
	      lo_transaction_type tx[$];
	      lo_transaction_type tmp_tx;
	      bit drop;
	
	      tr = null;
	
	      this.wait_if_stopped_or_empty(this.rx_obs_chan);
	      this.rx_obs_chan.get(tmp_tx);
	      tx.push_back(tmp_tx);
	
	      drop = 0;
	      \`vmm_callback(callback_type,
	                    post_rx_trans_obs(this, tx[tx.size()-1], drop));
	      if (drop) begin
	         tx.pop_back();
	         continue;
	      end
	
	      this.notify.indicate(this.SUB_OBS_RX, tx[tx.size()-1]);
	
	      \`vmm_debug(this.log, "Observed lower-level Rx transaction...");
	      \`vmm_verbose(this.log, tx[tx.size()-1].psdisplay("   "));
	
	      // ToDo: Check if the lower-level transactions observed so far
	      //       create a higher-level transaction
	
	      $cast(tr, this.rx_factory.copy());
	
	      if (tr != null) begin
	         drop = 0;
	
	         \`vmm_callback(callback_type,
	                       post_rx_trans(this, tx, tr, drop));
	
	         if (!drop) begin
	            this.notify.indicate(this.OBS_RX, tr);
	
	            \`vmm_trace(this.log, "Observed transaction...");
	            \`vmm_debug(this.log, tr.psdisplay("   "));
	
	            this.rx_chan.sneak(tr);
	         end
	
	         // ToDo: removed the interpreted observed sub transactions
	         tx.delete();
	      end
	   end
	endtask: rx_monitor
snippet vmm  VMM Full-Duplex Physical Driver (vmmgen)
	//
	// Template for VMM-compliant full-duplex physical-level transactor
	//
	// ${1:XACT}       Name of transactor
	// ${2:#(int DW=32, int AW=32)} Parameters
	// ${3:#(DW, AW)}  Parameter Instance
	// ${4:IF}         Name of physical interface
	// ${5:master}     Name of modport in physical interface
	// ${6:TR}         Name of input/output transaction descriptor class
	//
	
	\`include "vmm.sv"
	\`include "$4.sv"
	\`include "$6.sv"
	
	typedef class $1;
	
	class $1_callbacks $2 extends vmm_xactor_callbacks;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transactor_type;
	   typedef $6 $3 transaction_type;
	
	   ${7}
	   // ToDo: Add additional relevant callbacks
	   // ToDo: Use "function void" if callbacks cannot be blocking
	
	   // Called before a transaction is executed
	   virtual task pre_ex_trans(transactor_type xactor,
	                             transaction_type tr,
	                             ref bit drop);
	
	   endtask: pre_ex_trans
	
	   // Called after a transaction has been executed
	   virtual task post_ex_trans(transactor_type xactor,
	                              transaction_type tr);
	
	   endtask: post_ex_trans
	
	   // Called at start of observed transaction
	   virtual function void pre_obs_trans(transactor_type xactor,
	                                       transaction_type tr);
	
	   endfunction: pre_obs_trans
	
	   // Called before acknowledging a transaction
	   virtual function void pre_ack(transactor_type xactor,
	                                 transaction_type tr);
	
	   endfunction: pre_ack
	
	   // Called at end of observed transaction
	   virtual function void post_obs_trans(transactor_type xactor,
	                                        transaction_type tr);
	
	   endfunction: post_obs_trans
	
	endclass: $1_callbacks
	
	
	class $1_cfg;
	   // ToDo: Add transactor configuration class properties
	   rand int mode;
	endclass:$1_cfg
	
	
	class $1 $2 extends vmm_xactor;
	
	   typedef $1_callbacks $3 callback_type;
	   typedef $6 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	   typedef $1_cfg configuration_type;
	
	   int EXECUTING;
	   int OBSERVING;
	
	   protected configuration_type cfg;
	   local     configuration_type reset_cfg;
	   protected transaction_type rx_factory;
	   local     transaction_type reset_rx_factory;
	
	   channel_type in_chan;
	   channel_type out_chan;
	   virtual $4.$5 sigs;
	
	   extern function new(string inst,
	                       int stream_id,
	                       virtual $4.$5 sigs,
	                       configuration_type cfg = null,
	                       channel_type in_chan = null,
	                       channel_type out_chan = null,
	                       transaction_type rx_factory = null);
	
	   extern virtual function void reconfigure(configuration_type cfg);
	   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);
	   extern protected virtual task main();
	   extern protected virtual task tx_driver();
	   extern protected virtual task rx_monitor();
	
	endclass: $1
	
	
	function $1::new(string inst,
	                 int stream_id,
	                 virtual $4.$5 sigs,
	                 configuration_type cfg,
	                 channel_type in_chan,
	                 channel_type out_chan,
	                 transaction_type rx_factory);
	
	   super.new("$1 Transactor", inst, stream_id);
	
	   this.EXECUTING = this.notify.configure(-1, vmm_notify::ON_OFF);
	   this.OBSERVING = this.notify.configure(-1, vmm_notify::ON_OFF);
	
	
	   this.sigs = sigs;
	
	   if (cfg == null) cfg = new;
	   this.cfg = cfg;
	   this.reset_cfg = cfg;
	
	   if (in_chan == null) in_chan = new("$1 Input Channel", inst);
	   this.in_chan = in_chan;
	   if (out_chan == null) out_chan = new("$1 Output Channel", inst);
	   this.out_chan = out_chan;
	
	   if (rx_factory == null) rx_factory = new;
	   this.rx_factory = rx_factory;
	   this.reset_rx_factory = rx_factory;
	endfunction: new
	
	
	function void $1::reconfigure(configuration_type cfg);
	
	   if (!this.notify.is_on(XACTOR_IDLE)) begin
	      \`vmm_warning(this.log,
	                    "Transactor should be reconfigured only when IDLE");
	   end
	
	   this.cfg = cfg;
	
	   // ToDo: Notify any running threads of the new configuration
	endfunction: reconfigure
	
	
	function void $1::reset_xactor(reset_e rst_typ);
	
	   super.reset_xactor(rst_typ);
	
	   // ToDo: Reset output/inout signals
	   this.sigs.mck1.sync_txd <= 0;
	   this.sigs.mck1.sync_dat <= 'z;
	   this.sigs.async_en      <= 0;
	
	   this.in_chan.flush();
	   this.out_chan.flush();
	
	   // ToDo: Reset other state information
	
	   if (rst_typ != SOFT_RST) begin
	      // ToDo: Reset state if FIRM or above
	   end
	
	   if (rst_typ == PROTOCOL_RST) begin
	      // ToDo: Reset state if PROTOCOL
	   end
	
	   if (rst_typ == HARD_RST) begin
	      // ToDo: Reset state if HARD or above
	      this.cfg = this.reset_cfg;
	      this.rx_factory = this.reset_rx_factory;
	   end
	endfunction: reset_xactor
	
	
	task $1::main();
	   super.main();
	
	   fork
	      tx_driver();
	      rx_monitor();
	   join
	endtask: main
	
	
	task $1::tx_driver();
	
	   forever begin
	      transaction_type tr;
	      bit drop;
	
	      // ToDo: Set output/inout signals to their idle state
	      this.sigs.mck1.sync_txd <= 0;
	      this.sigs.async_en      <= 0;
	
	      this.wait_if_stopped_or_empty(this.in_chan);
	      this.in_chan.activate(tr);
	
	      drop = 0;
	      \`vmm_callback(callback_type,
	                     pre_ex_trans(this, tr, drop));
	      if (drop) begin
	         void'(this.in_chan.remove());
	         continue;
	      end
	
	      void'(this.in_chan.start());
	      this.notify.indicate(this.EXECUTING, tr);
	
	      \`vmm_trace(this.log, "Starting Tx transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      case (tr.kind)
	        transaction_type::READ: begin
	           // ToDo: Implement READ transaction
	        end
	
	        transaction_type::WRITE: begin
	           // ToDo: Implement READ transaction
	        end
	      endcase
	
	      this.notify.reset(this.EXECUTING);
	      void'(this.in_chan.complete());
	
	      \`vmm_trace(this.log, "Completed Tx transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      \`vmm_callback(callback_type,
	                     post_ex_trans(this, tr));
	
	      void'(this.in_chan.remove());
	   end
	endtask: tx_driver
	
	
	task $1::rx_monitor();
	
	   forever begin
	      transaction_type tr;
	
	      // ToDo: Set output signals to their idle state
	      this.sigs.mck1.sync_dat <= 'z;
	
	      // ToDo: Wait for start of transaction
	
	      $cast(tr, this.rx_factory.copy());
	      \`vmm_callback(callback_type,
	                     pre_obs_trans(this, tr));
	
	      tr.notify.indicate(vmm_data::STARTED);
	      this.notify.indicate(this.OBSERVING, tr);
	
	      \`vmm_trace(this.log, "Starting Rx transaction...");
	
	      // ToDo: Observe first half of transaction
	
	      tr.status = transaction_type::IS_OK;
	      \`vmm_callback(callback_type,
	                     pre_obs_trans(this, tr));
	
	      // ToDo: React to observed transaction with ACK/NAK
	
	      \`vmm_trace(this.log, "Completed Rx transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      this.notify.reset(this.OBSERVING);
	      tr.notify.indicate(vmm_data::ENDED);
	
	      \`vmm_callback(callback_type,
	                     post_obs_trans(this, tr));
	
	      this.out_chan.sneak(tr);
	   end
	endtask: rx_monitor
snippet vmm  VMM Full-Duplex Physical Monitor (vmmgen)
	//
	// Template for VMM-compliant full-duplex physical-level monitor
	//
	// ${1:XACT}       Name of transactor
	// ${2:#(int DW=32, int AW=32)} Parameters
	// ${3:#(DW, AW)}  Parameter Instance
	// ${4:IF}         Name of physical interface
	// ${5:passive}    Name of modport in physical interface
	// ${6:TR}         Name of input/output transaction descriptor class
	//
	
	\`include "vmm.sv"
	\`include "$4.sv"
	\`include "$6.sv"
	
	typedef class $1;
	
	class $1_callbacks $2 extends vmm_xactor_callbacks;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transactor_type;
	   typedef $6 $3 transaction_type;
	
	   ${7}
	   // ToDo: Add additional relevant callbacks
	   // ToDo: Use a task if callbacks can be blocking
	
	   // Called at start of observed transaction
	   virtual function void pre_tx_trans(transactor_type xactor,
					      transaction_type tr);
	   endfunction: pre_tx_trans
	
	   // Called at end of observed transaction
	   virtual function void post_tx_trans(transactor_type xactor,
					       transaction_type tr);
	   endfunction: post_tx_trans
	
	   // Called at start of observed transaction
	   virtual function void pre_rx_trans(transactor_type xactor,
					      transaction_type tr);
	   endfunction: pre_rx_trans
	
	   // Called at end of observed transaction
	   virtual function void post_rx_trans(transactor_type xactor,
					       transaction_type tr);
	   endfunction: post_rx_trans
	endclass:$1_callbacks
	
	
	class $1_cfg;
	   // ToDo: Add transactor configuration class properties
	   rand int mode;
	endclass:$1_cfg
	
	
	class $1 $2 extends vmm_xactor;
	
	   typedef $1_callbacks $3 callback_type;
	   typedef $6 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	   typedef $1_cfg configuration_type;
	
	   int OBS_ON_TX;
	   int OBS_ON_RX;
	
	   protected configuration_type cfg;
	   local     configuration_type reset_cfg;
	   protected transaction_type tx_factory;
	   local     transaction_type reset_tx_factory;
	   protected transaction_type rx_factory;
	   local     transaction_type reset_rx_factory;
	
	   channel_type tx_chan;
	   channel_type rx_chan;
	   virtual   $4.$5 sigs;
	
	   extern function new(string inst,
			       int stream_id,
			       virtual $4.$5 sigs,
			       configuration_type cfg = null,
			       channel_type tx_chan = null,
			       channel_type rx_chan = null,
			       transaction_type tx_factory = null,
			       transaction_type rx_factory = null);
	
	   extern virtual function void reconfigure(configuration_type cfg);
	   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);
	   extern protected virtual task main();
	   extern protected virtual task tx_monitor();
	   extern protected virtual task rx_monitor();
	
	endclass:$1
	
	
	function $1::new(string inst,
			 int stream_id,
			 virtual $4.$5 sigs,
			 configuration_type cfg,
			 channel_type tx_chan,
			 channel_type rx_chan,
			 transaction_type tx_factory,
			 transaction_type rx_factory);
	
	   super.new("$1 Transactor", inst, stream_id);
	
	   this.OBS_ON_TX = this.notify.configure(-1, vmm_notify::ON_OFF);
	   this.OBS_ON_RX = this.notify.configure(-1, vmm_notify::ON_OFF);
	
	   this.sigs = sigs;
	
	   if (cfg == null) cfg = new;
	   this.cfg = cfg;
	   this.reset_cfg = cfg;
	
	   if (tx_chan == null) tx_chan = new("$1 Tx Channel", inst);
	   this.tx_chan = tx_chan;
	   if (rx_chan == null) rx_chan = new("$1 Rx Channel", inst);
	   this.rx_chan = rx_chan;
	
	   if (tx_factory == null) tx_factory = new;
	   this.tx_factory = tx_factory;
	   this.reset_tx_factory = tx_factory;
	
	   if (rx_factory == null) rx_factory = new;
	   this.rx_factory = rx_factory;
	   this.reset_rx_factory = rx_factory;
	endfunction: new
	
	
	function void $1::reconfigure(configuration_type cfg);
	
	   if (!this.notify.is_on(XACTOR_IDLE)) begin
	      \`vmm_warning(this.log,
			   "Transactor should be reconfigured only when IDLE");
	   end
	
	   this.cfg = cfg;
	
	   // ToDo: Notify any running threads of the new configuration
	endfunction: reconfigure
	
	
	function void $1::reset_xactor(reset_e rst_typ);
	
	   super.reset_xactor(rst_typ);
	
	   this.tx_chan.flush();
	   this.rx_chan.flush();
	
	   // ToDo: Reset other state information
	
	   if (rst_typ != SOFT_RST) begin
	      // ToDo: Reset state if FIRM or above
	   end
	
	   if (rst_typ == PROTOCOL_RST) begin
	      // ToDo: Reset state if PROTOCOL
	   end
	
	   if (rst_typ == HARD_RST) begin
	      // ToDo: Reset state if HARD or above
	      this.cfg = this.reset_cfg;
	      this.tx_factory = this.reset_tx_factory;
	      this.rx_factory = this.reset_rx_factory;
	   end
	endfunction: reset_xactor
	
	
	task $1::main();
	   super.main();
	
	   fork
	      tx_monitor();
	      rx_monitor();
	   join
	endtask: main
	
	
	task $1::tx_monitor();
	
	   forever begin
	      transaction_type tr;
	
	      // ToDo: Wait for start of transaction
	
	      $cast(tr, this.tx_factory.copy());
	      \`vmm_callback(callback_type,
			    pre_tx_trans(this, tr));
	
	      tr.notify.indicate(vmm_data::STARTED);
	      this.notify.indicate(this.OBS_ON_TX, tr);
	
	      \`vmm_trace(this.log, "Starting Tx transaction...");
	
	      // ToDo: Observe transaction
	
	      \`vmm_trace(this.log, "Completed Tx transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      this.notify.reset(this.OBS_ON_TX);
	      tr.notify.indicate(vmm_data::ENDED);
	
	      \`vmm_callback(callback_type,
			    post_tx_trans(this, tr));
	
	      this.tx_chan.sneak(tr);
	   end
	endtask: tx_monitor
	
	
	task $1::rx_monitor();
	
	   forever begin
	      transaction_type tr;
	
	      // ToDo: Wait for start of transaction
	
	      $cast(tr, this.rx_factory.copy());
	      \`vmm_callback(callback_type,
			    pre_rx_trans(this, tr));
	
	      tr.notify.indicate(vmm_data::STARTED);
	      this.notify.indicate(this.OBS_ON_RX, tr);
	
	      \`vmm_trace(this.log, "Starting Rx transaction...");
	
	      // ToDo: Observe transaction
	
	      \`vmm_trace(this.log, "Completed Tx transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      this.notify.reset(this.OBS_ON_RX);
	      tr.notify.indicate(vmm_data::ENDED);
	
	      \`vmm_callback(callback_type,
			    post_rx_trans(this, tr));
	
	      this.rx_chan.sneak(tr);
	   end
	endtask: rx_monitor
snippet vmm  VMM Half-Duplex Functional Driver (vmmgen)
	//
	// Template for VMM-compliant half-duplex functional-level transactor
	//
	// ${1:XACT}       Name of transactor
	// ${2:#(int DW=32, int AW=32)} Parameters
	// ${3:#(DW, AW)}  Parameter Instance
	// ${4:TR}         Name of high-level transaction descriptor class
	// ${5:TX}         Name of low-level transaction descriptor class
	
	\`include "vmm.sv"
	\`include "$4.sv"
	\`include "$5.sv"
	
	typedef class $1;
	
	class $1_callbacks $2 extends vmm_xactor_callbacks;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transactor_type;
	   typedef $4 $3 hi_transaction_type;
	   typedef $5 $3 lo_transaction_type;
	
	   ${6}
	   // ToDo: Add additional relevant callbacks
	   // ToDo: Use a task if callbacks can be blocking
	
	   // Called before a transaction is executed
	   virtual task pre_trans(transactor_type xactor,
	                          hi_transaction_type tr,
	                          bit drop);
	   endtask: pre_trans
	
	   virtual function void pre_trans_exec(transactor_type xactor,
	                                        hi_transaction_type tr,
	                                        lo_transaction_type tx[$]);
	   endfunction: pre_trans_exec
	
	   // Called at start of lower transaction
	   virtual task pre_exec(transactor_type xactor,
	                         lo_transaction_type tx,
	                         bit drop);
	   endtask: pre_exec
	
	   // Called at end of lower transaction
	   virtual task post_exec(transactor_type xactor,
	                          lo_transaction_type tx);
	   endtask: post_exec
	
	   virtual function void post_trans_exec(transactor_type xactor,
	                                         hi_transaction_type tr,
	                                         lo_transaction_type tx[$]);
	   endfunction: post_trans_exec
	
	   // Called after a transaction has been executed
	   virtual task post_trans(transactor_type xactor,
	                           hi_transaction_type tr);
	   endtask: post_trans
	endclass:$1_callbacks
	
	
	class $1_cfg;
	   // ToDo: Add transactor configuration class properties
	   rand int mode;
	endclass: $1_cfg
	
	
	class $1 $2 extends vmm_xactor;
	   typedef $1_callbacks $3 callback_type;
	   typedef $4 $3 hi_transaction_type;
	   typedef $5 $3 lo_transaction_type;
	   typedef vmm_channel_typed #(hi_transaction_type) hi_channel_type;
	   typedef vmm_channel_typed #(lo_transaction_type) lo_channel_type;
	   typedef $1_cfg configuration_type;
	
	   int EXECUTING;
	   int SUB_EXECUTING;
	
	   protected configuration_type cfg;
	   local     configuration_type reset_cfg;
	
	   hi_channel_type in_chan;
	   lo_channel_type exec_chan;
	
	   extern function new(string inst,
	                       int stream_id,
	                       configuration_type cfg = null,
	                       hi_channel_type in_chan = null,
	                       lo_channel_type exec_chan = null);
	
	   extern virtual function void reconfigure(configuration_type cfg);
	   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);
	   extern protected virtual task main();
	   extern protected virtual task tx_driver();
	
	endclass: $1
	
	function $1::new(string inst,
	                 int stream_id,
	                 configuration_type cfg,
	                 hi_channel_type in_chan,
	                 lo_channel_type exec_chan);
	
	   super.new("$1 Transactor", inst, stream_id);
	
	   this.EXECUTING     = this.notify.configure(-1, vmm_notify::ON_OFF);
	   this.SUB_EXECUTING = this.notify.configure(-1, vmm_notify::ON_OFF);
	
	   if (cfg == null) cfg = new;
	   this.cfg = cfg;
	   this.reset_cfg = cfg;
	
	   if (in_chan == null) in_chan = new("$1 Input Channel", inst);
	   this.in_chan = in_chan;
	   if (exec_chan == null) exec_chan = new("$1 Execution Channel", inst);
	   this.exec_chan = exec_chan;
	endfunction: new
	
	
	function void $1::reconfigure(configuration_type cfg);
	
	   if (!this.notify.is_on(XACTOR_IDLE)) begin
	      \`vmm_warning(this.log,
	                    "Transactor should be reconfigured only when IDLE");
	   end
	
	   this.cfg = cfg;
	
	   // ToDo: Notify any running threads of the new configuration
	endfunction: reconfigure
	
	
	function void $1::reset_xactor(reset_e rst_typ);
	
	   super.reset_xactor(rst_typ);
	
	   this.in_chan.flush();
	   this.exec_chan.flush();
	
	   // ToDo: Reset other state information
	
	   if (rst_typ != SOFT_RST) begin
	      // ToDo: Reset state if FIRM or above
	   end
	
	   if (rst_typ == PROTOCOL_RST) begin
	      // ToDo: Reset state if PROTOCOL
	   end
	
	   if (rst_typ == HARD_RST) begin
	      // ToDo: Reset state if HARD or above
	      this.cfg = this.reset_cfg;
	   end
	endfunction: reset_xactor
	
	
	task $1::main();
	   super.main();
	
	   fork
	      tx_driver();
	   join
	endtask: main
	
	
	task $1::tx_driver();
	
	   forever begin
	      hi_transaction_type tr;
	      lo_transaction_type tx[$];
	      bit drop;
	
	      this.wait_if_stopped_or_empty(this.in_chan);
	      this.in_chan.activate(tr);
	
	      drop = 0;
	      \`vmm_callback(callback_type,
	                     pre_trans(this, tr, drop));
	      if (drop) begin
	         void'(this.in_chan.remove());
	         continue;
	      end
	
	      void'(this.in_chan.start());
	      this.notify.indicate(this.EXECUTING, tr);
	
	      \`vmm_trace(this.log, "Starting transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      // ToDo: Turn high-level transaction into a series of
	      //       low-level transactions
	
	      \`vmm_callback(callback_type,
	                     pre_trans_exec(this, tr, tx));
	
	      foreach (tx[i]) begin
	         drop = 0;
	         \`vmm_callback(callback_type,
				pre_exec(this, tx[i], drop));
	         if (drop) continue;
	
	         this.notify.indicate(this.SUB_EXECUTING, tx[i]);
	
	         \`vmm_debug(this.log, "Executing lower-level transaction...");
	         \`vmm_verbose(this.log, tx[i].psdisplay("   "));
	
	         this.exec_chan.put(tx[i]);
	
	         // ToDo: Add completion model if not blocking
	
	         this.notify.reset(this.SUB_EXECUTING);
	
	         \`vmm_debug(this.log, "Executed lower-level transaction...");
	         \`vmm_verbose(this.log, tx[i].psdisplay("   "));
	
	         \`vmm_callback(callback_type,
				post_exec(this, tx[i]));
	      end // foreach (tx[i])
	
	      \`vmm_callback(callback_type,
	                     post_trans_exec(this, tr, tx));
	
	      // ToDo: Determine result of high-level transaction from the
	      //       results of the low-level transactions
	
	      this.notify.reset(this.EXECUTING);
	      void'(this.in_chan.complete());
	
	      \`vmm_trace(this.log, "Completed transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      \`vmm_callback(callback_type,
	                     post_trans(this, tr));
	
	      void'(this.in_chan.remove());
	   end
	endtask: tx_driver
snippet vmm  VMM Half-Duplex Functional Monitor (vmmgen)
	//
	// Template for VMM-compliant half-duplex functional-level monitor
	//
	// ${1:XACT}       Name of transactor
	// ${2:#(int DW=32, int AW=32)} Parameters
	// ${3:#(DW, AW)}  Parameter Instance
	// ${4:TR}         Name of high-level transaction descriptor class
	// ${5:TX}         Name of low-level transaction descriptor class
	
	\`include "vmm.sv"
	\`include "$4.sv"
	\`include "$5.sv"
	
	typedef class $1;
	
	class $1_callbacks $2 extends vmm_xactor_callbacks;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transactor_type;
	   typedef $4 $3 hi_transaction_type;
	   typedef $5 $3 lo_transaction_type;
	
	   ${6}
	  // ToDo: Add additional relevant callbacks
	  // ToDo: Use a task if callbacks can be blocking
	
	  // Called at end of observed lower-level transaction
	  virtual function void post_trans_obs(transactor_type xactor,
					       lo_transaction_type tx,
					       bit drop);
	  endfunction: post_trans_obs
	
	   // Call when a high-level transaction has been identified
	   virtual function post_trans(transactor_type xactor,
				       lo_transaction_type tx[$],
				       hi_transaction_type tr,
				       bit drop);
	   endfunction: post_trans
	
	endclass: $1_callbacks
	
	
	class $1_cfg;
	   // ToDo: Add transactor configuration class properties
	   rand int mode;
	endclass: $1_cfg
	
	
	class $1 $2 extends vmm_xactor;
	   typedef $1_callbacks $3 callback_type;
	   typedef $4 $3 hi_transaction_type;
	   typedef $5 $3 lo_transaction_type;
	   typedef vmm_channel_typed #(hi_transaction_type) hi_channel_type;
	   typedef vmm_channel_typed #(lo_transaction_type) lo_channel_type;
	   typedef $1_cfg configuration_type;
	
	   int OBSERVED;
	   int SUB_OBSERVED;
	
	   protected configuration_type cfg;
	   local     configuration_type reset_cfg;
	   protected hi_transaction_type rx_factory;
	   local     hi_transaction_type reset_rx_factory;
	
	   hi_channel_type out_chan;
	   lo_channel_type obs_chan;
	
	
	   extern function new(string inst,
			       int stream_id,
			       configuration_type cfg = null,
			       hi_channel_type out_chan = null,
			       lo_channel_type obs_chan = null,
			       hi_transaction_type rx_factory = null);
	
	   extern virtual function void reconfigure(configuration_type cfg);
	   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);
	   extern protected virtual task main();
	   extern protected virtual task rx_monitor();
	
	endclass: $1
	
	
	function $1::new(string inst,
			 int stream_id,
			 configuration_type cfg,
			 hi_channel_type out_chan,
			 lo_channel_type obs_chan,
			 hi_transaction_type rx_factory);
	
	   super.new("$1 Transactor", inst, stream_id);
	
	   this.OBSERVED = this.notify.configure();
	   this.SUB_OBSERVED = this.notify.configure();
	
	   if (cfg == null) cfg = new;
	   this.cfg = cfg;
	   this.reset_cfg = cfg;
	
	   if (out_chan == null) out_chan = new("$1 Output Channel", inst);
	   this.out_chan = out_chan;
	   if (obs_chan == null) obs_chan = new("$1 Observation Channel", inst);
	   this.obs_chan = obs_chan;
	
	   if (rx_factory == null) rx_factory = new;
	   this.rx_factory = rx_factory;
	   this.reset_rx_factory = rx_factory;
	endfunction: new
	
	
	function void $1::reconfigure(configuration_type cfg);
	
	   if (!this.notify.is_on(XACTOR_IDLE)) begin
	      \`vmm_warning(this.log,
	                    "Transactor should be reconfigured only when IDLE");
	   end
	
	   this.cfg = cfg;
	
	   // ToDo: Notify any running threads of the new configuration
	endfunction: reconfigure
	
	
	function void $1::reset_xactor(reset_e rst_typ);
	
	   super.reset_xactor(rst_typ);
	
	   this.out_chan.flush();
	   this.obs_chan.flush();
	
	   // ToDo: Reset other state information
	
	   if (rst_typ != SOFT_RST) begin
	      // ToDo: Reset state if FIRM or above
	   end
	
	   if (rst_typ == PROTOCOL_RST) begin
	      // ToDo: Reset state if PROTOCOL
	   end
	
	   if (rst_typ == HARD_RST) begin
	      // ToDo: Reset state if HARD or above
	      this.cfg = this.reset_cfg;
	      this.rx_factory = this.reset_rx_factory;
	   end
	endfunction: reset_xactor
	
	
	task $1::main();
	   super.main();
	
	   fork
	      rx_monitor();
	   join
	endtask: main
	
	
	task $1::rx_monitor();
	
	   forever begin
	      hi_transaction_type tr;
	      lo_transaction_type tx[$];
	      lo_transaction_type tmp_tx;
	      bit drop;
	
	      tr = null;
	
	      this.wait_if_stopped_or_empty(this.obs_chan);
	      this.obs_chan.get(tmp_tx);
	      tx.push_back(tmp_tx);
	
	      drop = 0;
	      \`vmm_callback(callback_type,
			    post_trans_obs(this, tx[tx.size()-1], drop));
	      if (drop) begin
		 tx.pop_back();
		 continue;
	      end
	
	      this.notify.indicate(this.SUB_OBSERVED, tx[tx.size()-1]);
	
	      \`vmm_debug(this.log, "Observed lower-level transaction...");
	      \`vmm_verbose(this.log, tx[tx.size()-1].psdisplay("   "));
	
	      // ToDo: Check if the lower-level transactions observed so far
	      //       create a higher-level transaction
	
	      $cast(tr, this.rx_factory.copy());
	
	      if (tr != null) begin
		 drop = 0;
	
		 \`vmm_callback(callback_type,
			       post_trans(this, tx, tr, drop));
	
		 if (!drop) begin
		    this.notify.indicate(this.OBSERVED, tr);
	
		    \`vmm_trace(this.log, "Observed transaction...");
		    \`vmm_debug(this.log, tr.psdisplay("   "));
	
		    this.out_chan.sneak(tr);
		 end
	
		 // ToDo: removed the interpreted observed sub transactions
		 tx.delete();
	      end
	   end
	endtask: rx_monitor
snippet vmm  VMM Half-Duplex Physical Driver (vmmgen)
	//
	// Template for VMM-compliant half-duplex physical-level transactor
	//
	// ${1:XACT}       Name of transactor
	// ${2:#(int DW=32, int AW=32)} Parameters
	// ${3:#(DW, AW)}  Parameter Instance
	// ${4:IF}         Name of physical interface
	// ${5:master}     Name of modport in physical interface
	// ${6:TR}         Name of input transaction descriptor class
	//
	
	\`include "vmm.sv"
	\`include "$4.sv"
	\`include "$6.sv"
	
	typedef class $1;
	
	class $1_callbacks $2 extends vmm_xactor_callbacks;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transactor_type;
	   typedef $6 $3 transaction_type;
	
	   ${7}
	  // ToDo: Add additional relevant callbacks
	  // ToDo: Use "function void" if callbacks cannot be blocking
	
	   // Called before a transaction is executed
	   virtual task pre_trans(transactor_type xactor,
	                          transaction_type tr,
	                          ref bit drop);
	   endtask: pre_trans
	
	   // Called after a transaction has been executed
	   virtual task post_trans(transactor_type xactor,
	                           transaction_type tr);
	   endtask: post_trans
	endclass: $1_callbacks
	
	
	class $1_cfg;
	   // ToDo: Add transactor configuration class properties
	   rand int mode;
	endclass: $1_cfg
	
	
	class $1 $2 extends vmm_xactor;
	
	   typedef $1_callbacks $3 callback_type;
	   typedef $6 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	   typedef $1_cfg configuration_type;
	
	   int EXECUTING;
	
	   protected configuration_type cfg;
	   local     configuration_type reset_cfg;
	
	   channel_type in_chan;
	   virtual $4.$5 sigs;
	
	   extern function new(string inst,
	                       int stream_id,
	                       virtual $4.$5 sigs,
	                       configuration_type cfg = null,
	                       channel_type in_chan = null);
	
	   extern virtual function void reconfigure(configuration_type cfg);
	   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);
	   extern protected virtual task main();
	
	endclass: $1
	
	
	function $1::new(string inst,
	                 int stream_id,
	                 virtual $4.$5 sigs,
	                 configuration_type cfg,
	                 channel_type in_chan);
	
	   super.new("$1 Transactor", inst, stream_id);
	
	   this.EXECUTING = this.notify.configure(-1, vmm_notify::ON_OFF);
	
	   this.sigs = sigs;
	
	   if (cfg == null) cfg = new;
	   this.cfg = cfg;
	   this.reset_cfg = cfg;
	
	   if (in_chan == null) in_chan = new("$1 Input Channel", inst);
	   this.in_chan = in_chan;
	endfunction: new
	
	
	function void $1::reconfigure(configuration_type cfg);
	
	   if (!this.notify.is_on(XACTOR_IDLE)) begin
	      \`vmm_warning(this.log,
	                    "Transactor should be reconfigured only when IDLE");
	   end
	
	   this.cfg = cfg;
	
	   // ToDo: Notify any running threads of the new configuration
	endfunction: reconfigure
	
	
	function void $1::reset_xactor(reset_e rst_typ);
	
	   super.reset_xactor(rst_typ);
	
	   // ToDo: Reset output signals
	   this.sigs.mck1.sync_txd <= 0;
	   this.sigs.mck1.sync_dat <= 'z;
	   this.sigs.async_en      <= 0;
	
	   this.in_chan.flush();
	
	   // ToDo: Reset other state information
	
	   if (rst_typ != SOFT_RST) begin
	      // ToDo: Reset state if FIRM or above
	   end
	
	   if (rst_typ == PROTOCOL_RST) begin
	      // ToDo: Reset state if PROTOCOL
	   end
	
	   if (rst_typ == HARD_RST) begin
	      // ToDo: Reset state if HARD or above
	      this.cfg = this.reset_cfg;
	   end
	endfunction: reset_xactor
	
	
	task $1::main();
	   super.main();
	
	   forever begin
	      transaction_type tr;
	      bit drop;
	
	      // ToDo: Set output signals to their idle state
	      this.sigs.mck1.sync_txd <= 0;
	      this.sigs.mck1.sync_dat <= 'z;
	      this.sigs.async_en      <= 0;
	
	      this.wait_if_stopped_or_empty(this.in_chan);
	      this.in_chan.activate(tr);
	
	      drop = 0;
	      \`vmm_callback(callback_type,
	                     pre_trans(this, tr, drop));
	      if (drop) begin
	         void'(this.in_chan.remove());
	         continue;
	      end
	
	      void'(this.in_chan.start());
	      this.notify.indicate(this.EXECUTING, tr);
	
	      \`vmm_trace(this.log, "Starting transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      case (tr.kind)
	         transaction_type::READ: begin
	            // ToDo: Implement READ transaction
	         end
	
	         transaction_type::WRITE: begin
	            // ToDo: Implement WRITE transaction
	         end
	      endcase
	
	      this.notify.reset(this.EXECUTING);
	      void'(this.in_chan.complete());
	
	      \`vmm_trace(this.log, "Completed transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      \`vmm_callback(callback_type,
	                    post_trans(this, tr));
	
	      void'(this.in_chan.remove());
	   end
	endtask: main
snippet vmm  VMM Half-Duplex Physical Monitor (vmmgen)
	//
	// Template for VMM-compliant half-duplex physical-level monitor
	//
	// ${1:XACT}       Name of transactor
	// ${2:#(int DW=32, int AW=32)} Parameters
	// ${3:#(DW, AW)}  Parameter Instance
	// ${4:IF}         Name of physical interface
	// ${5:slave}      Name of modport in physical interface
	// ${6:TR}         Name of output transaction descriptor class
	//
	
	\`include "vmm.sv"
	\`include "$4.sv"
	\`include "$6.sv"
	
	typedef class $1;
	
	class $1_callbacks $2 extends vmm_xactor_callbacks;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transactor_type;
	   typedef $6 $3 transaction_type;
	
	   ${7}
	   // ToDo: Add additional relevant callbacks
	   // ToDo: Use a task if callbacks can be blocking
	
	   // Called at start of observed transaction
	   virtual function void pre_trans(transactor_type xactor,
					   transaction_type tr);
	   endfunction: pre_trans
	
	   // Called before acknowledging a transaction
	   virtual function pre_ack(transactor_type xactor,
				    transaction_type tr);
	   endfunction: pre_ack
	
	   // Called at end of observed transaction
	   virtual function void post_trans(transactor_type xactor,
					    transaction_type tr);
	   endfunction: post_trans
	
	endclass: $1_callbacks
	
	
	class $1_cfg;
	   // ToDo: Add transactor configuration class properties
	   rand int mode;
	endclass: $1_cfg
	
	
	class $1 $2 extends vmm_xactor;
	
	   typedef $1_callbacks $3 callback_type;
	   typedef $6 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	   typedef $1_cfg configuration_type;
	
	   int OBSERVING;
	
	   protected configuration_type cfg;
	   local     configuration_type reset_cfg;
	   protected transaction_type rx_factory;
	   local     transaction_type reset_rx_factory;
	
	   channel_type out_chan;
	   virtual $4.$5 sigs;
	
	   extern function new(string inst,
			       int stream_id,
			       virtual $4.$5 sigs,
			       configuration_type cfg = null,
			       channel_type out_chan = null,
			       transaction_type rx_factory = null);
	
	   extern virtual function void reconfigure(configuration_type cfg);
	   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);
	   extern protected virtual task main();
	
	endclass: $1
	
	
	function $1::new(string inst,
			   int stream_id,
			   virtual $4.$5 sigs,
			   configuration_type cfg,
			   channel_type out_chan,
			   transaction_type rx_factory);
	
	   super.new("$1 Transactor", inst, stream_id);
	
	   this.OBSERVING = this.notify.configure(-1, vmm_notify::ON_OFF);
	
	   this.sigs = sigs;
	
	   if (cfg == null) cfg = new;
	   this.cfg = cfg;
	   this.reset_cfg = cfg;
	
	   if (out_chan == null) out_chan = new("$1 Output Channel", inst);
	   this.out_chan = out_chan;
	
	   if (rx_factory == null) rx_factory = new;
	   this.rx_factory = rx_factory;
	   this.reset_rx_factory = rx_factory;
	endfunction: new
	
	
	function void $1::reconfigure(configuration_type cfg);
	
	   if (!this.notify.is_on(XACTOR_IDLE)) begin
	      \`vmm_warning(this.log,
		    "Transactor should be reconfigured only when IDLE");
	   end
	
	   this.cfg = cfg;
	
	   // ToDo: Notify any running threads of the new configuration
	endfunction: reconfigure
	
	
	function void $1::reset_xactor(reset_e rst_typ);
	
	   super.reset_xactor(rst_typ);
	
	   // ToDo: Reset output signals
	   this.sigs.sck1.sync_dat <= 'z;
	   this.sigs.sck2.sync_rxd <= 0;
	   this.sigs.async_rdy     <= 0;
	
	   this.out_chan.flush();
	
	   // ToDo: Reset other state information
	
	   if (rst_typ != SOFT_RST) begin
	      // ToDo: Reset state if FIRM or above
	   end
	
	   if (rst_typ == PROTOCOL_RST) begin
	      // ToDo: Reset state if PROTOCOL
	   end
	
	   if (rst_typ == HARD_RST) begin
	      // ToDo: Reset state if HARD or above
	      this.cfg = this.reset_cfg;
	      this.rx_factory = this.reset_rx_factory;
	   end
	endfunction: reset_xactor
	
	
	task $1::main();
	   super.main();
	
	   forever begin
	      transaction_type tr;
	
	      // ToDo: Set output signals to their idle state
	      this.sigs.sck1.sync_dat <= 'z;
	      this.sigs.sck2.sync_rxd <= 0;
	      this.sigs.async_rdy     <= 0;
	
	      // ToDo: Wait for start of transaction
	
	      $cast(tr, this.rx_factory.copy());
	      \`vmm_callback(callback_type,
			     pre_trans(this, tr));
	
	      tr.notify.indicate(vmm_data::STARTED);
	      this.notify.indicate(this.OBSERVING, tr);
	
	      \`vmm_trace(this.log, "Starting transaction...");
	
	      // ToDo: Observe first half of transaction
	
	      tr.status = transaction_type::IS_OK;
	      \`vmm_callback(callback_type,
			    pre_ack(this, tr));
	
	      // ToDo: React to observed transaction with ACK/NAK
	
	      \`vmm_trace(this.log, "Completed transaction...");
	      \`vmm_debug(this.log, tr.psdisplay("   "));
	
	      this.notify.reset(this.OBSERVING);
	      tr.notify.indicate(vmm_data::ENDED);
	
	      \`vmm_callback(callback_type,
			    post_trans(this, tr));
	
	      this.out_chan.sneak(tr);
	   end
	endtask: main
snippet vmm  VMM Interface (vmmgen)
	//
	// Template for VMM-compliant interface
	//
	// ${1:IF}        Name of physical bus
	//
	
	\`include "vmm.sv"
	
	
	// ToDo: One clock per clock domain
	
	interface $1(input bit ck1,
		     input bit ck2);
	   ${2}
	   // ToDo: Define default setup & hold times
	   parameter setup_time = 5/*ns*/;
	   parameter hold_time  = 3/*ns*/;
	
	   // ToDo: Define synchronous and asynchronous signals as wires
	
	   wire [15:0] sync_txd;
	   wire [15:0] sync_rxd;
	   wire [15:0] sync_dat;
	
	   logic       async_en;
	   logic       async_rdy;
	
	
	   // ToDo: Define one clocking block per clock domain
	   //       with synchronous signal direction from a
	   //       master perspective
	
	   clocking mck1 @(posedge ck1);
	      default input #setup_time output #hold_time;
	      output sync_txd;
	      inout  sync_dat;
	   endclocking: mck1
	
	   clocking mck2 @(posedge ck2);
	      default input #setup_time output #hold_time;
	      input sync_rxd;
	   endclocking: mck2
	
	
	   // ToDo: Define one clocking block per clock domain
	   //       with synchronous signal direction from a
	   //       slave perspective
	
	   clocking sck1 @(posedge ck1);
	      default input #setup_time output #hold_time;
	      input sync_txd;
	      inout sync_dat;
	   endclocking: sck1
	
	   clocking sck2 @(posedge ck2);
	      default input #setup_time output #hold_time;
	      output sync_rxd;
	   endclocking: sck2
	
	
	   // ToDo: Define one clocking block per clock domain
	   //       with synchronous signal direction from a
	   //       monitor perspective
	
	   clocking pck1 @(posedge ck1);
	      default input #setup_time output #hold_time;
	      input sync_txd;
	      input sync_dat;
	   endclocking: pck1
	
	   clocking pck2 @(posedge ck2);
	      default input #setup_time output #hold_time;
	      input sync_rxd;
	   endclocking: pck2
	
	
	   // ToDo: Define a modport for each master, slave and
	   //       monitor, with appropriate asynchronous signal
	   //       directions and clocking blocks
	
	   modport master(clocking mck1,
			  clocking mck2,
			  output async_en,
			  input  async_rdy);
	
	   modport slave(clocking sck1,
			 clocking sck2,
			 input  async_en,
			 output async_rdy);
	
	   modport passive(clocking pck1,
			   clocking pck2,
			   input async_en,
			   input async_rdy);
	endinterface: $1
snippet interface  VMM Interface (vmmgen)
	//
	// Template for VMM-compliant interface
	//
	// ${1:IF}        Name of physical bus
	//
	
	\`include "vmm.sv"
	
	
	// ToDo: One clock per clock domain
	
	interface $1(input bit ck1,
		     input bit ck2);
	   ${2}
	   // ToDo: Define default setup & hold times
	   parameter setup_time = 5/*ns*/;
	   parameter hold_time  = 3/*ns*/;
	
	   // ToDo: Define synchronous and asynchronous signals as wires
	
	   wire [15:0] sync_txd;
	   wire [15:0] sync_rxd;
	   wire [15:0] sync_dat;
	
	   logic       async_en;
	   logic       async_rdy;
	
	
	   // ToDo: Define one clocking block per clock domain
	   //       with synchronous signal direction from a
	   //       master perspective
	
	   clocking mck1 @(posedge ck1);
	      default input #setup_time output #hold_time;
	      output sync_txd;
	      inout  sync_dat;
	   endclocking: mck1
	
	   clocking mck2 @(posedge ck2);
	      default input #setup_time output #hold_time;
	      input sync_rxd;
	   endclocking: mck2
	
	
	   // ToDo: Define one clocking block per clock domain
	   //       with synchronous signal direction from a
	   //       slave perspective
	
	   clocking sck1 @(posedge ck1);
	      default input #setup_time output #hold_time;
	      input sync_txd;
	      inout sync_dat;
	   endclocking: sck1
	
	   clocking sck2 @(posedge ck2);
	      default input #setup_time output #hold_time;
	      output sync_rxd;
	   endclocking: sck2
	
	
	   // ToDo: Define one clocking block per clock domain
	   //       with synchronous signal direction from a
	   //       monitor perspective
	
	   clocking pck1 @(posedge ck1);
	      default input #setup_time output #hold_time;
	      input sync_txd;
	      input sync_dat;
	   endclocking: pck1
	
	   clocking pck2 @(posedge ck2);
	      default input #setup_time output #hold_time;
	      input sync_rxd;
	   endclocking: pck2
	
	
	   // ToDo: Define a modport for each master, slave and
	   //       monitor, with appropriate asynchronous signal
	   //       directions and clocking blocks
	
	   modport master(clocking mck1,
			  clocking mck2,
			  output async_en,
			  input  async_rdy);
	
	   modport slave(clocking sck1,
			 clocking sck2,
			 input  async_en,
			 output async_rdy);
	
	   modport passive(clocking pck1,
			   clocking pck2,
			   input async_en,
			   input async_rdy);
	endinterface: $1
snippet vmm  VMM Ral Env (vmmgen)
	//
	// Template for VMM-compliant RAL-based verification environment
	//
	// ${1:RAL}       Name of top-level RAL model
	// ${2:XACT}      Name of RAL access transactor
	// ${3:tb_env}    Name of the TestBench Environment
	//
	
	
	\`include "vmm_ral.sv"
	
	${4}
	// ToDo: Add additional required \`include directives
	
	class test_cfg;
	
	   // ToDo: Define test configuration parameters (e.g. how long to run)
	
	   function new();
	   endfunction: new
	
	   function string psdisplay(string prefix = "");
	   endfunction
	endclass: test_cfg
	
	
	class scoreboard;
	   test_cfg cfg;
	   vmm_log  log;
	
	   function new(test_cfg cfg);
	      this.cfg = cfg;
	      this.log = new("Scoreboard", "");
	   endfunction: new
	
	endclass
	
	
	class $3 extends vmm_ral_env;
	   test_cfg cfg;
	
	   $1 ral_model;
	   $2 host;
	
	   // ToDo: Declare transactor instances as data members
	
	   scoreboard sb;
	
	
	   function new();
	      super.new();
	      this.cfg = new;
	      $timeformat(-9, 0, "ns", 1);
	
	      this.ral_model = new();
	      super.ral.set_model(this.ral_model);
	   endfunction: new
	
	
	   virtual function void gen_cfg();
	      super.gen_cfg();
	
	      if (!this.cfg.randomize()) begin
		 \`vmm_fatal(log, "Failed to randomize test configuration");
	      end
	   endfunction: gen_cfg
	
	
	   virtual function void build();
	      super.build();
	
	      \`vmm_note(this.log, this.cfg.psdisplay());
	
	      this.host = new( /* ToDo: Supply suitable arguments */ );
	      super.ral.add_xactor(this.host);
	
	      // ToDo: Instantiate transactors, using XMRs to access interface instances
	      // ToDo: Register any required callbacks
	
	      this.sb = new(this.cfg);
	
	      // ToDo: Start transactors needed to configure the DUT
	      this.host.start_xactor();
	   endfunction: build
	
	
	   virtual task hw_reset();
	      // ToDo: Apply hardware reset to DUT
	   endtask: hw_reset
	
	
	   virtual task cfg_dut();
	      super.cfg_dut();
	
	      // ToDo: Configure DUT
	   endtask: cfg_dut
	
	
	   virtual task start();
	      super.start();
	
	      // ToDo: Start all transactors
	   endtask: start
	
	
	   virtual task wait_for_end();
	      super.wait_for_end();
	
	      // ToDo: Figure out when it is time to end the test
	   endtask: wait_for_end
	
	
	   virtual task stop();
	      super.stop();
	
	      // ToDo: Stop all generators
	
	      // ToDo: Let the DUT drain of all pending data
	   endtask: stop
	
	
	   virtual task cleanup();
	      super.cleanup();
	
	      // ToDo: check that nothing was lost
	   endtask: cleanup
	endclass: $3
	
snippet vmm  VMM Ral Multi-Domain Bfm (vmmgen)
	//
	// Template for physical access BFM that can be used by RAL
	//
	// ${1:XACT}       Name of physical-level transactor
	// ${2:TR}         Name of physical-level transaction descriptor class
	// ${3:DOM}        Name of domain
	//
	
	\`include "$1.sv"
	\`include "vmm_ral.sv"
	
	class $1_$3_ral_bfm extends vmm_rw_xactor;
	   $1 bfm;
	
	   function new(string inst,
			int unsigned stream_id,
			$1 bfm);
	      super.new("$1 RAL Master for $3 domain", inst, stream_id);
	
	      this.bfm = bfm;
	   endfunction: new
	
	
	   virtual function void start_xactor();
	      super.start_xactor();
	      this.bfm.start_xactor();
	   endfunction
	
	
	   virtual function void stop_xactor();
	      super.stop_xactor();
	      this.bfm.stop_xactor();
	   endfunction
	
	
	   virtual function void reset_xactor(vmm_xactor::reset_e
					      rst_typ = vmm_xactor::SOFT_RST);
	      super.reset_xactor(rst_typ);
	      this.bfm.reset_xactor(rst_typ);
	   endfunction
	
	
	   virtual task execute_single(vmm_rw_access tr);
	      $2 cyc;
	      ${4}
	      // ToDo: Translate the generic RW into an appropriate RW
	      // for the specified domain
	      cyc = new;
	      if (tr.kind == vmm_rw::WRITE) begin
		 // Write cycle
		 // ...
	      end
	      else begin
		 // Read cycle
		 // ...
	      end
	
	      this.bfm.in_chan.put(cyc);
	
	      // ToDo: Send the result of read cycles back to the RAL
	      if (tr.kind == vmm_rw::READ) begin
		 tr.data = ...
	      end
	   endtask: execute_single
	endclass: $1_$3_ral_bfm
	
snippet vmm  VMM RAL Single-Domain Bfm (vmmgen)
	//
	// Template for physical access BFM that can be used by RAL
	//
	// ${1:XACT}       Name of physical-level transactor
	// ${2:TR}         Name of physical-level transaction descriptor class
	// ${3:VIF}        Name of virtual interface used by transactor
	//
	
	\`include "$1.sv"
	\`include "vmm_ral.sv"
	
	class $1_ral_bfm extends vmm_rw_xactor;
	   $1 bfm;
	
	   function new(string inst,
			int unsigned stream_id,
			virtual $3 sigs);
	      super.new("$1 RAL BFM", inst, stream_id);
	
	      this.bfm = new(inst, stream_id, sigs);
	   endfunction: new
	
	
	   virtual function void start_xactor();
	      super.start_xactor();
	      this.bfm.start_xactor();
	   endfunction
	
	
	   virtual function void stop_xactor();
	      super.stop_xactor();
	      this.bfm.stop_xactor();
	   endfunction
	
	
	   virtual function void reset_xactor(vmm_xactor::reset_e
					      rst_typ = vmm_xactor::SOFT_RST);
	      super.reset_xactor(rst_typ);
	      this.bfm.reset_xactor(rst_typ);
	   endfunction
	
	
	   virtual task execute_single(vmm_rw_access tr);
	      $2 cyc;
	      ${4}
	      // ToDo: Translate the generic RW into a simple RW
	      cyc = new;
	      if (tr.kind == vmm_rw::WRITE) begin
		 // Write cycle
		 // ...
	      end
	      else begin
		 // Read cycle
		 // ...
	      end
	
	      this.bfm.in_chan.put(cyc);
	
	      // ToDo: Send the result of read cycles back to the RAL
	      if (tr.kind == vmm_rw::READ) begin
		 tr.data = ...
	      end
	   endtask: execute_single
	endclass: $1_ral_bfm
	
snippet vmm  VMM Scenario Gen (vmm version 1.1.1)
	\`include "vmm.sv"
	
	// ${1:XACTN} -- Name of the transaction descriptor class
	// ${2:#(int DW=32, int AW=32)} -- Transaction Descriptor Class Parameters
	// ${3:#(DW, AW)}  Parameter Instance
	// ${4:GEN} -- Name of the Atomic generator being defined
	${5}
	class $1_scenario $2 extends vmm_scenario; 
	
	   typedef $1 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	   typedef $1_scenario $3 scenario_type;
	
	   static vmm_log log = new("$1", "class"); 
	 
	   rand transaction_type items[]; 
	        transaction_type using; 
	 
	   local virtual function string this_class_name(); 
	      return "$1 $2"; 
	   endfunction: this_class_name 
	 
	   local virtual function vmm_log get_vmm_log(); 
	      return this.log; 
	   endfunction: get_vmm_log 
	 
	   local virtual function string __default_name(); 
	      return "Undefined $1 Scenario"; 
	   endfunction: __default_name 
	 
	   virtual function string psdisplay(string prefix = ""); 
	      psdisplay = super.psdisplay(prefix); 
	      foreach (this.items[i]) begin 
	         string pfx; 
	         if (this.items[i] == null) continue; 
	         $sformat(pfx, "%s  Item[%0d]: ", prefix, i); 
	         psdisplay = {psdisplay, "n", this.items[i].psdisplay(pfx)}; 
	      end 
	      if (this.using != null) begin 
	         psdisplay = {psdisplay, "n", this.using.psdisplay({prefix, "  Using: "})}; 
	      end 
	      return psdisplay; 
	   endfunction: psdisplay 
	 
	   constraint vmm_scenario_valid_$1 { 
	      items.size() == length; 
	 
	\`ifdef VMM_SOLVE_BEFORE_SIZE 
	      solve length before items.size \`VMM_SOLVE_BEFORE_OPT; 
	\`endif 
	   } 
	 
	   function new(\`VMM_SCENARIO_NEW_ARGS); 
	      super.new(null \`VMM_SCENARIO_NEW_CALL); 
	      using = null; 
	   endfunction: new 
	 
	   virtual function vmm_data copy(vmm_data to = null); 
	      scenario_type cpy; 
	 
	      if (to == null) cpy = new(); 
	      else if (!$cast(cpy, to)) begin 
	         \`vmm_fatal(this.log, {"Cannot copy to non-$1_scenario instance"}); 
	         return null; 
	      end 
	 
	      void'(super.copy(cpy)); 
	      cpy.items = new [this.items.size()]; 
	      foreach (this.items[i]) begin 
	         if (this.items[i] == null) cpy.items[i] = null; 
	         else $cast(cpy.items[i], this.items[i].copy()); 
	      end 
	      if (this.using == null) cpy.using = null; 
	      else $cast(cpy.using, this.using.copy()); 
	 
	      return cpy; 
	   endfunction: copy 
	 
	   function void allocate_scenario(transaction_type using = null); 
	      this.items = new [this.get_max_length()]; 
	      foreach (this.items[i]) begin 
	         if (using == null) this.items[i] = new; 
	         else $cast(this.items[i], using.copy()); 
	         \`VMM_OBJECT_SET_PARENT(this.items[i], this) 
	 
	         this.items[i].stream_id   = this.stream_id; 
	         this.items[i].scenario_id = this.scenario_id; 
	         this.items[i].data_id     = i; 
	      end 
	   endfunction: allocate_scenario 
	 
	   function void fill_scenario(transaction_type using = null); 
	      int i; 
	 
	      if (this.items.size() < this.get_max_length()) begin 
	         this.items = new [this.get_max_length()] (this.items); 
	      end 
	      foreach (this.items[i]) begin 
	         if (this.items[i] != null) continue; 
	 
	         if (using == null) this.items[i] = new; 
	         else $cast(this.items[i], using.copy()); 
	         \`VMM_OBJECT_SET_PARENT(this.items[i], this) 
	 
	         this.items[i].stream_id   = this.stream_id; 
	         this.items[i].scenario_id = this.scenario_id; 
	         this.items[i].data_id     = i; 
	      end 
	   endfunction: fill_scenario 
	 
	   function void pre_randomize(); 
	      this.fill_scenario(this.using); 
	   endfunction: pre_randomize 
	 
	   virtual task apply(channel_type     channel, 
	                      ref int unsigned n_insts); 
	      int i; 
	 
	      for (i = 0; i < this.length; i++) begin 
	         transaction_type item; 
	         $cast(item, this.items[i].copy()); 
	\`ifndef VMM_GRAB_DISABLED 
	         channel.put(item,,this); 
	\`else 
	         channel.put(item); 
	\`endif 
	      end 
	 
	      n_insts = this.length; 
	   endtask: apply 
	endclass: $1_scenario
	 
	 
	class $1_inject_item_scenario $2 extends $1_scenario $3;
	   typedef $1 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	 
	   function new(transaction_type obj \`VMM_DATA_NEW_ARGS); 
	      super.new(\`VMM_DATA_NEW_CALL); 
	 
	      this.items    = new [1]; 
	      this.items[0] = obj; 
	      this.length   = 1; 
	      this.repeated = 0; 
	      void'(this.define_scenario("Directed 'inject_obj()' transaction", 1)); 
	   endfunction: new 
	 
	   virtual task apply(channel_type     channel, 
	                      ref int unsigned n_insts); 
	\`ifndef VMM_GRAB_DISABLED 
	      channel.put(this.items[0],,this); 
	\`else 
	      channel.put(this.items[0]); 
	\`endif 
	      n_insts = 1; 
	   endtask: apply 
	 
	endclass: $1_inject_item_scenario
	 
	 
	class $1_atomic_scenario $2 extends $1_scenario $3; 
	   typedef $1 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	 
	   int unsigned ATOMIC; 
	 
	   constraint atomic_scenario { 
	      if (scenario_kind == ATOMIC) { 
	         length == 1; 
	         repeated == 0; 
	      } 
	   } 
	 
	   function new(\`VMM_DATA_NEW_ARGS); 
	      super.new(\`VMM_DATA_NEW_CALL); 
	 
	      this.ATOMIC = this.define_scenario("Atomic", 1); 
	 
	      this.scenario_kind   = this.ATOMIC; 
	      this.length = 1; 
	   endfunction: new 
	 
	   virtual function string psdisplay(string prefix = ""); 
	      psdisplay = super.psdisplay(prefix); 
	   endfunction:psdisplay 
	 
	   function void pre_randomize(); 
	      super.pre_randomize(); 
	   endfunction 
	 
	   virtual task apply(channel_type     channel, 
	                      ref int unsigned n_insts); 
	      super.apply(channel, n_insts); 
	   endtask: apply 
	 
	endclass: $1_atomic_scenario
	 
	 
	class $1_scenario_election $2; 
	   typedef $1_scenario $3 scenario_type;
	
	   int stream_id; 
	   int scenario_id; 
	   int unsigned n_scenarios; 
	   int unsigned last_selected[$]; 
	   int unsigned next_in_set; 
	 
	   scenario_type scenario_set[$]; 
	 
	   rand int select; 
	 
	   constraint vmm_scenario_election_valid_$1 { 
	      select >= 0; 
	      select < n_scenarios; 
	   } 
	 
	   constraint round_robin { 
	      select == next_in_set; 
	   } 
	 
	endclass: $1_scenario_election
	 
	typedef class $4; 
	 
	class $4_callbacks $2 extends vmm_xactor_callbacks; 
	   typedef $4 $3 transactor_type;
	   typedef $1_scenario $3 scenario_type;
	
	   virtual task pre_scenario_randomize(transactor_type gen, 
	                                       ref scenario_type scenario); 
	   endtask 
	 
	   virtual task post_scenario_gen(transactor_type gen, 
	                                  scenario_type scenario, 
	                                  ref bit dropped); 
	   endtask 
	endclass: $4_callbacks
	 
	 
	class $4 $2 extends vmm_xactor; 
	 
	   typedef $4 $3 transactor_type;
	   typedef $1_scenario $3 scenario_type;
	   typedef $4_callbacks $3 callback_type;
	   typedef $1_scenario_election $3 election_type;
	   typedef $1_atomic_scenario $3 atomic_scenario_type;
	   typedef $1_inject_item_scenario $3 inject_item_scenario_type;
	   typedef $1 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	   
	   int unsigned stop_after_n_insts; 
	   int unsigned stop_after_n_scenarios; 
	 
	   typedef enum int {GENERATED, 
	                     DONE} symbols_e; 
	 
	   election_type select_scenario; 
	 
	   scenario_type scenario_set[$]; 
	   protected scenario_type scenario_registry[string]; 
	 
	   channel_type out_chan; 
	 
	   protected int scenario_count; 
	   protected int inst_count; 
	 
	   virtual function string psdisplay(string prefix = ""); 
	      psdisplay = super.psdisplay(prefix); 
	      $sformat(psdisplay, "%s [stops after #insts %0d>%0d or #scenarios %0d>%0d]", 
	               psdisplay, this.inst_count, this.stop_after_n_insts, 
	               this.scenario_count, this.stop_after_n_scenarios); 
	      $sformat(psdisplay, "%sn%sOutChan: %s(%s) [level=%0d of %0d]", 
	               psdisplay, prefix, this.out_chan.log.get_name(), 
	               this.out_chan.log.get_instance(), this.out_chan.level(), 
	               this.out_chan.full_level()); 
	      foreach (this.scenario_registry[name]) begin 
	         psdisplay = {psdisplay, "n", 
	                      this.scenario_registry[name].psdisplay(prefix)}; 
	      end 
	      return psdisplay; 
	   endfunction: psdisplay 
	 
	   function new(string       inst, 
	                int          stream_id = -1, 
	                channel_type out_chan  = null 
	                \`VMM_XACTOR_NEW_ARGS); 
	      super.new("$1 Scenario Generator", inst, stream_id 
	                \`VMM_XACTOR_NEW_CALL); 
	 
	      if (out_chan == null) begin 
	         out_chan = new("$1 Scenario Generator output channel", 
	                        inst); 
	         \`VMM_OBJECT_SET_PARENT(out_chan, this) 
	      end 
	      this.out_chan = out_chan; 
	      this.out_chan.set_producer(this); 
	      this.log.is_above(this.out_chan.log); 
	 
	      this.scenario_count = 0; 
	      this.inst_count = 0; 
	      this.stop_after_n_insts     = 0; 
	      this.stop_after_n_scenarios = 0; 
	 
	      this.select_scenario = new; 
	      begin 
	         atomic_scenario_type sc = new; 
	         \`VMM_OBJECT_SET_PARENT(sc, this) 
	         this.register_scenario("Atomic", sc); 
	      end 
	 
	      void'(this.notify.configure(GENERATED)); 
	      void'(this.notify.configure(DONE, vmm_notify::ON_OFF)); 
	   endfunction: new 
	 
	   virtual function void register_scenario(string name, 
	                                           scenario_type scenario); 
	      if(name == "") begin 
	         \`vmm_error(this.log, \`vmm_sformatf("Invalid '%s' string was passed", name)); 
	         return; 
	      end 
	
	      if(this.scenario_registry.exists(name)) begin 
	         \`vmm_error(this.log, \`vmm_sformatf("%s already has an entry in the scenario registry", name)); 
	         return; 
	      end 
	
	      if(scenario == null) begin 
	         \`vmm_error(this.log, \`vmm_sformatf("scenario passed for %s is a null value", name)); 
	         return; 
	      end 
	
	      this.scenario_registry[name] = scenario; 
	
	      foreach(this.scenario_set[i]) begin 
	         if(this.scenario_set[i] == scenario) 
	            return; 
	      end 
	      this.scenario_set.push_back(scenario); 
	   endfunction: register_scenario 
	
	   virtual function bit scenario_exists(string name); 
	        if(name == "") begin 
	            \`vmm_error(this.log, \`vmm_sformatf("Invalid '%s' string was passed", name)); 
	            return 0; 
	        end 
	
	        if(this.scenario_registry.exists(name)) 
	            scenario_exists = 1; 
	        else 
	            scenario_exists = 0; 
	    endfunction: scenario_exists 
	
	   virtual function void replace_scenario(string name, 
	                                           scenario_type scenario); 
	      if(name == "") begin 
	         \`vmm_error(this.log, \`vmm_sformatf("Invalid '%s' string was passed", name)); 
	         return; 
	      end 
	
	      if(scenario == null) begin 
	         \`vmm_error(this.log, \`vmm_sformatf("scenario passed for %s is a null value", name)); 
	         return; 
	      end 
	
	      if(!this.scenario_registry.exists(name)) begin 
	         \`vmm_error(this.log, \`vmm_sformatf("cannot replace a unregistered %s entry [use register_scenario]", name)); 
	         return ; 
	      end 
	
	      foreach(this.scenario_set[i]) begin 
	         if(this.scenario_set[i] == this.scenario_registry[name]) begin 
	            this.scenario_set.delete(i); 
	            break; 
	         end 
	      end 
	      this.scenario_registry[name] = scenario; 
	      foreach(this.scenario_set[i]) begin 
	          if(this.scenario_set[i] == scenario) 
	              return; 
	      end 
	      this.scenario_set.push_back(scenario); 
	   endfunction: replace_scenario 
	
	   virtual function void get_all_scenario_names(ref string name[$]); 
	      string s; 
	
	      if(this.scenario_registry.first(s)) begin 
	         do begin 
	            name.push_back(s); 
	         end while(this.scenario_registry.next(s)); 
	      end 
	      if(name.size() == 0) begin 
	         \`vmm_warning(this.log, "There are no entries in the scenario generator registry"); 
	      end 
	   endfunction: get_all_scenario_names 
	
	   virtual function void get_names_by_scenario(scenario_type scenario, 
	                                               ref string name[$]); 
	      string s; 
	
	      if(scenario == null) begin 
	         \`vmm_error(this.log, \`vmm_sformatf("scenario is a null value")); 
	         return; 
	      end 
	
	      if(this.scenario_registry.first(s)) begin 
	         do begin 
	            if(this.scenario_registry[s] == scenario) 
	               name.push_back(s); 
	         end while(this.scenario_registry.next(s)); 
	      end 
	      if(name.size() == 0) begin 
	         \`vmm_warning(this.log, "There are no entries in the scenario registry"); 
	      end 
	   endfunction: get_names_by_scenario 
	
	   virtual function string get_scenario_name(scenario_type scenario); 
	        string s[$]; 
	
	        if(scenario == null) begin 
	            \`vmm_error(this.log, \`vmm_sformatf("scenario is a null value")); 
	            return ""; 
	        end 
	
	        this.get_names_by_scenario(scenario, s); 
	
	        if(s.size()) 
	            get_scenario_name = s[0]; 
	        else 
	            get_scenario_name = ""; 
	   endfunction: get_scenario_name 
	
	   virtual function int get_scenario_index(scenario_type scenario); 
	       get_scenario_index = -1; 
	       foreach(this.scenario_set[i]) begin 
	          if(this.scenario_set[i] == scenario) begin 
	             return i; 
	          end 
	       end 
	       if(get_scenario_index == -1) begin 
	          \`vmm_warning(this.log, \`vmm_sformatf("Cannot find the index for the scenario")); 
	       end 
	   endfunction: get_scenario_index 
	
	   virtual function bit unregister_scenario(scenario_type scenario); 
	      string s; 
	      unregister_scenario=0; 
	
	      if(scenario == null) begin 
	         \`vmm_error(this.log, \`vmm_sformatf("scenario is a null value")); 
	         return 0; 
	      end 
	      if(this.scenario_registry.first(s)) begin 
	         do begin 
	            if(this.scenario_registry[s] == scenario) begin 
	               this.scenario_registry.delete(s); 
	               unregister_scenario=1; 
	            end 
	         end while(this.scenario_registry.next(s)); 
	      end 
	      if(unregister_scenario==0) begin 
	         \`vmm_warning(this.log, "There are no entries in the scenario registry"); 
	      end 
	      if(unregister_scenario) begin 
	         foreach(this.scenario_set[i]) begin 
	            if(this.scenario_set[i] == scenario) begin 
	               this.scenario_set.delete(i); 
	               break; 
	            end 
	         end 
	      end 
	   endfunction: unregister_scenario 
	
	   virtual function scenario_type unregister_scenario_by_name(string name); 
	      if(name == "") begin 
	         \`vmm_error(this.log, \`vmm_sformatf("Invalid '%s' string was passed", name)); 
	         return null; 
	      end 
	      if(!this.scenario_registry.exists(name)) begin 
	         \`vmm_warning(this.log, \`vmm_sformatf("There is no entry for %s in the scenario registry", name)); 
	         return null; 
	      end 
	      else begin 
	         unregister_scenario_by_name = this.scenario_registry[name]; 
	         foreach(this.scenario_set[i]) begin 
	            if(this.scenario_set[i] == this.scenario_registry[name]) begin 
	               this.scenario_set.delete(i); 
	               break; 
	            end 
	         end 
	         this.scenario_registry.delete(name); 
	      end 
	   endfunction: unregister_scenario_by_name 
	
	   virtual function scenario_type get_scenario(string name); 
	      if(name == "") begin 
	         \`vmm_error(this.log, \`vmm_sformatf("Invalid '%s' string was passed", name)); 
	         return null; 
	      end 
	      if(!this.scenario_registry.exists(name)) begin 
	         \`vmm_error(this.log, \`vmm_sformatf("%s does not have an entry in the scenario registry", name)); 
	         return null; 
	      end 
	
	      get_scenario = this.scenario_registry[name]; 
	      if(get_scenario == null) 
	         \`vmm_warning(this.log, \`vmm_sformatf("%s has a null scenario associated with it in the scenario registry", name)); 
	
	   endfunction: get_scenario 
	 
	   function int unsigned get_n_insts(); 
	      get_n_insts = this.inst_count; 
	   endfunction: get_n_insts 
	 
	   function int unsigned get_n_scenarios(); 
	      get_n_scenarios = this.scenario_count; 
	   endfunction: get_n_scenarios 
	 
	   virtual task inject_obj(transaction_type obj); 
	      inject_item_scenario_type scenario = new(obj); 
	      this.inject(scenario); 
	   endtask: inject_obj 
	 
	   virtual task inject(scenario_type scenario); 
	      bit drop = 0; 
	 
	      scenario.stream_id   = this.stream_id; 
	      scenario.scenario_id = this.scenario_count; 
	      foreach (scenario.items[i]) begin 
	         scenario.items[i].stream_id   = scenario.stream_id; 
	         scenario.items[i].scenario_id = scenario.scenario_id; 
	         scenario.items[i].data_id     = i; 
	      end 
	 
	      \`vmm_callback(callback_type, 
	                    post_scenario_gen(this, scenario, drop)); 
	 
	      if (!drop) begin 
	         this.scenario_count++; 
	         this.notify.indicate(GENERATED, scenario); 
	 
	         if (scenario.repeated > scenario.repeat_thresh) begin 
	            \`vmm_warning(this.log, \`vmm_sformatf("A scenario will be repeated %0d times...", 
	                                                 scenario.repeated)); 
	         end 
	         repeat (scenario.repeated + 1) begin 
	            int unsigned n_insts = 0; 
	            scenario.apply(this.out_chan, n_insts); 
	            this.inst_count += n_insts; 
	         end 
	      end 
	   endtask: inject 
	 
	   virtual function void reset_xactor(vmm_xactor::reset_e rst_typ = SOFT_RST); 
	      super.reset_xactor(rst_typ); 
	      this.scenario_count = 0; 
	      this.inst_count     = 0; 
	      this.out_chan.flush(); 
	      \`vmm_delQ(this.select_scenario.last_selected); 
	 
	      if (rst_typ >= FIRM_RST) begin 
	         this.notify.reset( , vmm_notify::HARD); 
	      end 
	 
	      if (rst_typ >= HARD_RST) begin 
	         atomic_scenario_type sc = new; 
	         \`VMM_OBJECT_SET_PARENT(sc, this) 
	 
	         this.stop_after_n_insts     = 0; 
	         this.stop_after_n_scenarios = 0; 
	         this.select_scenario = new; 
	         this.scenario_set.push_back(sc); 
	      end 
	 
	   endfunction: reset_xactor 
	 
	   virtual protected task main(); 
	      scenario_type the_scenario; 
	 
	      fork 
	         super.main(); 
	      join_none 
	 
	      if(this.scenario_set.size() == 0) 
	          return; 
	 
	      while ((this.stop_after_n_insts <= 0 
	              || this.inst_count < this.stop_after_n_insts) 
	             && (this.stop_after_n_scenarios <= 0 
	                 || this.scenario_count < this.stop_after_n_scenarios)) begin 
	 
	         this.wait_if_stopped(); 
	 
	         this.select_scenario.stream_id    = this.stream_id; 
	         this.select_scenario.scenario_id  = this.scenario_count; 
	         this.select_scenario.n_scenarios  = this.scenario_set.size(); 
	         this.select_scenario.scenario_set = this.scenario_set; 
	         if (this.select_scenario.last_selected.size() == 0) 
	            this.select_scenario.next_in_set = 0; 
	         else 
	            this.select_scenario.next_in_set = ((this.select_scenario.last_selected[$] + 1) % this.scenario_set.size()); 
	 
	         if (!this.select_scenario.randomize()) begin 
	            \`vmm_fatal(this.log, "Cannot select scenario descriptor"); 
	            continue; 
	         end 
	 
	         if (this.select_scenario.select < 0 || 
	             this.select_scenario.select >= this.scenario_set.size()) begin 
	            \`vmm_fatal(this.log, \`vmm_sformatf("Select scenario #%0d is not within available set (0-%0d)", 
	                                               this.select_scenario.select, 
	                                               this.scenario_set.size()-1)); 
	            continue; 
	         end 
	 
	         this.select_scenario.last_selected.push_back(this.select_scenario.select); 
	         while (this.select_scenario.last_selected.size() > 10) begin 
	            void'(this.select_scenario.last_selected.pop_front()); 
	         end 
	 
	         the_scenario = this.scenario_set[this.select_scenario.select]; 
	         if (the_scenario == null) begin 
	            \`vmm_fatal(this.log, \`vmm_sformatf("Selected scenario #%0d does not exist", 
	                                               this.select_scenario.select)); 
	            continue; 
	         end 
	 
	         the_scenario.stream_id   = this.stream_id; 
	         the_scenario.scenario_id = this.scenario_count; 
	         foreach (the_scenario.items[i]) begin 
	            if (the_scenario.items[i] == null) continue; 
	 
	            the_scenario.items[i].stream_id   = the_scenario.stream_id; 
	            the_scenario.items[i].scenario_id = the_scenario.scenario_id; 
	            the_scenario.items[i].data_id     = i; 
	         end 
	 
	         \`vmm_callback(callback_type, 
	                       pre_scenario_randomize(this, the_scenario)); 
	         if (the_scenario == null) continue; 
	 
	         if (!the_scenario.randomize()) begin 
	            \`vmm_fatal(this.log, $psprintf("Cannot randomize scenario descriptor #%0d", 
	                                           this.select_scenario.select)); 
	            continue; 
	         end 
	 
	         this.inject(the_scenario); 
	      end 
	 
	      this.notify.indicate(DONE); 
	      this.notify.indicate(XACTOR_STOPPED); 
	      this.notify.indicate(XACTOR_IDLE); 
	      this.notify.reset(XACTOR_BUSY); 
	      this.scenario_count++; 
	   endtask: main 
	  
	endclass: $4
snippet vmm  VMM Testbench Env (vmmgen)
	//
	// Template for VMM-compliant testcase
	//
	// ${1:TB_ENV}   Name of verification environment
	//
	
	\`include "$1.sv"
	
	program test;
	
	   vmm_log log = new("Test", "Main");
	   $1 env = new;
	   ${2}
	   // ToDo: Declare and implement callback extensions, if needed
	
	   initial begin
	      // ToDo: Set configuration parameters and turn rand mode OFF, if needed
	
	      env.build();
	
	      // ToDo: Set message service interface verbosity, if needed
	
	      // ToDo: Replace factory instances, if needed
	
	      env.start();
	
	      fork begin
		 // ToDo: Directed stimulus, if needed
	      end
	      join_none
	
	      env.run();
	   end
	
	endprogram: test
snippet vmm  VMM Testcase (vmmgen)
	//
	// Template for VMM-compliant testcase
	//
	// ${1:TB_ENV}   Name of verification environment
	//
	
	\`include "$1.sv"
	
	program test;
	
	   vmm_log log = new("Test", "Main");
	   $1 env = new;
	
	   ${2}
	   // ToDo: Declare and implement callback extensions, if needed
	   initial begin
	      // ToDo: Set configuration parameters and turn rand mode OFF, if needed
	
	      env.build();
	
	      // ToDo: Set message service interface verbosity, if needed
	
	      // ToDo: Replace factory instances, if needed
	
	      env.start();
	
	      fork begin
	   	 // ToDo: Directed stimulus, if needed
	      end
	      join_none
	
	      env.run();
	   end
	
	endprogram: test
snippet vmm  VMM Transaction (vmmgen version)
	//
	// Template for VMM-compliant transaction descriptor
	//
	// ${1:TR} -- Name of transaction descriptor class
	// ${2:#(int DW=32, int AW=32)} -- transaction descriptor class parameters
	// ${3:#(DW, AW)}  -- Parameter Instance
	//
	
	\`include "vmm.sv"
	
	class $1 $2 extends vmm_data;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	
	   static vmm_log log = new("$1", "class");
	
	   // ToDo: Modify/add symbolic transaction identifiers to match
	   ${4}
	   typedef enum {READ, WRITE } kinds_e;
	   rand kinds_e kind;
	
	   // ToDo: Add relevant class properties to define all transactions
	
	   // ToDo: Modify/add symbolic transaction identifiers to match
	   typedef enum {IS_OK, ERROR} status_e;
	   rand status_e status;
	
	   constraint $1_valid {
	      // ToDo: Define constraint to make descriptor valid
	      status == IS_OK;
	   }
	
	   // ToDo: Add constraint blocks to prevent error injection
	
	   function new();
	      super.new(this.log);
	   endfunction: new
	
	   extern virtual function string psdisplay(string prefix = "");
	   extern virtual function bit is_valid(bit silent = 1,
						input int kind   = -1);
	   extern virtual function vmm_data allocate();
	   extern virtual function vmm_data copy(vmm_data cpy = null);
	   extern virtual function bit compare(vmm_data to,
					       output string diff,
					       input int kind = -1);
	   extern virtual function int unsigned byte_size(int kind = -1);
	   extern virtual function int unsigned
	     byte_pack(ref logic [7:0]    bytes[],
		       input int unsigned offset = 0,
		       input int kind   = -1);
	   extern virtual function int unsigned
	     byte_unpack(const ref logic [7:0] bytes[],
			 input int unsigned offset = 0,
			 input int len    = -1,
			 input int kind   = -1);
	
	endclass: $1
	
	function string $1::psdisplay(string prefix = "");
	
	   // ToDo: Implement this method
	
	endfunction: psdisplay
	
	function bit $1::is_valid(bit silent = 1,
					   input int kind   = -1);
	
	   // ToDo: Implement this method
	
	endfunction: is_valid
	
	function vmm_data allocate();
	   transaction_type tr = new;
	   allocate = tr;
	endfunction: allocate
	
	function vmm_data $1::copy(vmm_data cpy = null);
	
	   transaction_type to;
	
	   // Copying to a new instance?
	   if (cpy == null)
		to = new;
	   else
		// Copying to an existing instance. Correct type?
		if (!$cast(to, cpy)) begin
		   \`vmm_fatal(this.log, "Attempting to copy to a non $1 instance");
		   return null;
		end
	
	   super.copy_data(to);
	
	   to.kind = this.kind;
	
	   // ToDo: Copy additional class properties
	
	   copy = to;
	
	endfunction: copy
	
	function bit $1::compare(vmm_data to,
				 output string diff,
				 input int kind = -1);
	
	   transaction_type tr;
	
	   compare = 0;
	   if (to == null) begin
		 \`vmm_fatal(this.log, "Cannot compare to NULL instance");
		 return 0;
	   end
	
	   if (!$cast(tr,to)) begin
		 \`vmm_fatal(this.log, "Attempting to compare to a non $1 instance");
		 return 0;
	   end
	
	   if (this.kind != tr.kind) begin
		 $sformat(diff, "Kind %0s != %0s", this.kind, tr.kind);
		 return 0;
	   end
	   // ToDo: Compare additional class properties
	
	   compare = 1;
	
	endfunction: compare
	
	function int unsigned $1::byte_size(int kind = -1);
	
	   // ToDo: Implement this method
	
	endfunction: byte_size
	
	function int unsigned
	  $1::byte_pack(ref logic [7:0]    bytes[],
		    input int unsigned offset = 0,
		    input int kind   = -1);
	
	   // ToDo: Implement this method
	
	endfunction: byte_pack
	
	function int unsigned
	  $1::byte_unpack(const ref logic [7:0] bytes[],
			  input int unsigned offset = 0,
			  input int len    = -1,
			  input int kind   = -1);
	
	   // ToDo: Implement this method
	
	endfunction: byte_unpack
	
	\`vmm_channel($1)
	\`vmm_atomic_gen($1, "$1")
	\`vmm_scenario_gen($1, "$1")
snippet vmm  VMM Transaction Test (vmmgen)
	//
	// Template for testing the implementation of a VMM-compliant
	// transaction descriptor
	//
	// % vcs -R -sverilog -ntb_opts rvm TR_test.sv
	//
	// ${1:TR}         Name of transaction descriptor class
	//
	
	program test;
	
	\`include "vmm.sv"
	\`include "$1.sv"
	   ${2}
	   initial begin
	      vmm_log log = new("$1", "Descriptor Test");
	      $1 obj = new;
	      $1 cpy;
	      $1 sb[$];
	      logic [7:0] bytes[];
	      string diff;
	      int n, m;
	      int fp;
	
	      fp = $fopen("$1.sav", "wb");
	      if (fp == 0) \`vmm_fatal(log, "Cannot open file '$1.sav'");
	
	      repeat (100) begin
		 if (!obj.randomize()) begin
		    \`vmm_error(log, "Failed to randomize object");
		    obj.display("Contradiction: ");
		 end
		 else obj.display("");
	
		 if (!obj.is_valid()) begin
		    \`vmm_error(log, "$1::is_valid() did not validate random value");
		    obj.display("Invalid: ");
		 end
	
		 if (!$cast(cpy, obj.allocate())) begin
		    \`vmm_error(log, "$1::allocate() did not allocate a $1 instance");
		    cpy.display("Allocated: ");
		 end
	
		 if (cpy.log != obj.log) begin
		    \`vmm_error(log, "$1::log is not a static data member");
		    \`vmm_note(obj.log, "Original message interface");
		    \`vmm_note(cpy.log, "Copy message interface");
		 end
	
		 if (!$cast(cpy, obj.copy())) begin
		    \`vmm_error(log, "$1::copy() did not allocate a $1 instance");
		    cpy.display("Allocated: ");
		 end
		 if (!cpy.compare(obj, diff)) begin
		    \`vmm_error(log, {"$1::copy() did not new-copy/compare: ", diff});
		    cpy.display("Copy: ");
		 end
	
		 cpy = new;
		 obj.copy(cpy);
		 if (!cpy.compare(obj, diff)) begin
		    \`vmm_error(log, {"$1::copy() did not copy/compare: ", diff});
		    cpy.display("Copy: ");
		 end
	
	\`ifndef NO_PACKING
		 cpy = new;
		 bytes = new[0];
		 n = obj.byte_pack(bytes);
		 m = obj.byte_size();
		 if (n != m) begin
		    \`vmm_error(log, $psprintf("$1::byte_pack() did not pack $1::byte_size() number of bytes: %d vs. %d", n, m));
		 end
	
		 m = cpy.byte_unpack(bytes);
		 if (n != m) begin
		    \`vmm_error(log, $psprintf("$1::byte_pack()/byte_unpack() did not pack then unpack same number of bytes: %d then %d", n, m));
		 end
	
		 if (!cpy.compare(obj, diff)) begin
		    \`vmm_error(log, {"$1::byte_pack()/byte_unpack() did not pack/unpack/compare: ", diff});
		    cpy.display("Copy: ");
		 end
	
		 cpy.save(fp);
		 sb.push_back(cpy);
		 $write("------------------------------------\n");
	      end // repeat (100)
	
	      $fclose(fp);
	
	      fp = $fopen("$1.sav", "rb");
	      if (fp == 0) \`vmm_fatal(log, "Cannot re-open file '$1.sav'");
	
	      repeat (100) begin
		 if (!obj.load(fp)) \`vmm_error(log, "Error occured while loading object");
		 obj.display("Loaded: ");
		 cpy = sb.pop_front();
		 if (!cpy.compare(obj, diff)) begin
		    \`vmm_error(log, {"$1::save()/load() did not save/load/compare: ", diff});
		    cpy.display("Saved: ");
		 end
		 $write("------------------------------------\n");
	      end // repeat (100)
	\`endif
	
	      log.report();
	   end
	
	endprogram: test
snippet vmm  VMM Transaction (custom)
	// ${1:name_xactn} -- name of the transaction
	// ${2:#(int DW=32, int AW=32)} -- transaction descriptor class parameters
	// ${3:#(DW, AW)}  Parameter Instance
	
	class $1 $2 extends vmm_data;
	   // some typedefs to ease up parameters usage
	   typedef $1 $3 transaction_type;
	   typedef vmm_channel_typed #(transaction_type) channel_type;
	
	   static vmm_log log = new("$1", "class");
	
	   // ToDo: Modify/add symbolic transaction identifiers to match
	   ${4}
	   typedef enum {READ, WRITE } kinds_e;
	   rand kinds_e kind;
	
	   // vmm rule 4-59: All class properties corresponding to a
	   // protocol property or field shall have the rand attribute
	
	   // use rand snippet to define attributes with constraints :)
	   // rand ....
	
	   // transaction time
	   time xactn_time;
	
	   function new();
	      super.new(this.log);
	   endfunction: new
	
	   // VMM 4-76: All classes derived from the vmm_data class shall provide
	   // implementations for the psdisplay(), is_valid(), allocate(), copy() and
	   // compare() virtual methods.
	   extern virtual function string psdisplay(string prefix = "");
	
	   extern virtual function bit is_valid(bit silent = 1, int kind = -1);
	
	   extern virtual function vmm_data allocate();
	
	   extern virtual function vmm_data copy(vmm_data to=null);
	
	   extern virtual function bit compare(vmm_data to,
					       output string diff,
					       input int kind = -1);
	
	   // VMM 4-77: All classes derived from the vmm_data class should provide
	   // implementations for the byte_size(), byte_pack() and byte_unpack() virtual
	   // methods.
	   extern virtual function int unsigned byte_size(input int kind = -1);
	
	   extern virtual function int unsigned byte_pack(ref logic[7:0] bytes[],
							  input int unsigned
								    offset = 0,
							  input int kind = -1);
	
	   extern virtual function int unsigned byte_unpack(const ref logic[7:0]
								      bytes[],
							    input int unsigned
								      offset = 0,
							    input int len = -1,
							    input int kind = -1);
	
	   // Pre-Randomize function. Add initialization of dynamic arrays here -- when
	   // initializing, make there size maximum possible.
	   function void pre_randomize();
	      super.pre_randomize();
	   endfunction // pre_randomize
	
	   // Post-Randomize -- initialize the data which gets its value from the
	   // randomized fields -- for example the CRC
	   function void post_randomize();
	      super.post_randomize();
	   endfunction // post_randomize
	
	endclass: $1
	
	function vmm_data $1::allocate();
	      transaction_type tr = new;
	      return tr;
	endfunction: allocate
	
	// Copy the current value of the object instance to the specified instance
	function vmm_data $1::copy(vmm_data to=null);
	   transaction_type xactn;
	   if (to != null) begin
	     if (!$cast(xactn, to)) begin
		\`vmm_fatal(log, "Not a $1 instance");
		return null;
	     end
	   end else xactn = new;
	   super.copy_data(xactn);
	
	   \`vmm_fatal(log, "$1 Copy function not implemented yet");
	   // xactn.kind = this.kind;
	   // Copy class members here ...;
	
	   return xactn;
	endfunction: copy
	
	function string $1::psdisplay(string prefix = "");
	   // $sformat(psdisplay, "%s$1 %s @ 0x%h = 0h%h", prefix,
	   //        this.kind.name(), // other variables here
	   //        );
	   \`vmm_fatal(log, "$1 psdisplay function not implemented yet");
	endfunction: psdisplay
	
	function bit $1::is_valid(bit silent = 1, int kind = -1);
	   return 1;
	endfunction: is_valid
	
	// compare the values of various elements of the objects
	// Use kind argument to implement partial compare etc.
	function bit $1::compare(input vmm_data to, output string diff,
				 input int kind = -1);
	   transaction_type xactn;
	   if(to == null) begin
	      \`vmm_fatal(log, "Can not compare to NULL reference");
	      // return 0; // After fatal, this line would not be reached anyway
	   end // if (to == null)
	   else if (!$cast(xactn, to)) begin
	      \`vmm_fatal(log, "Can not copy a non-$1 instance");
	      // return 0; // After fatal, this line would not be reached anyway
	   end
	   // if (this.kind != xactn.kind) begin
	   //   $sformat(diff, "Kind %s != %s", this.kind, xactn.kind);
	   //   return 0;
	   // end
	   // compare other variables here
	   \`vmm_fatal(log, "$1 compare function not implemented yet");
	   return 1;
	endfunction: compare
	
	function int unsigned $1::byte_size(input int kind = -1);
	   \`vmm_fatal(log, "$1 byte_size function not implemented yet");
	endfunction: byte_size
	
	function int unsigned $1::byte_pack(ref logic[7:0] bytes[],
					    input int unsigned
					    offset = 0,
					    input int kind = -1);
	   \`vmm_fatal(log, "$1 byte_pack function not implemented yet");
	endfunction: byte_pack
	
	function int unsigned $1::byte_unpack(const ref logic[7:0] bytes[],
					      input int unsigned offset = 0,
					      input int len = -1,
					      input int kind = -1);
	   \`vmm_fatal(log, "$1 byte_unpack function not implemented yet");
	endfunction: byte_unpack
	
	
	// \`vmm_atomic_gen($1, "$1")
	// \`vmm_scenario_gen($1, "$1")
snippet while  while() ..
	while (${1:condition}) begin
	   ${2}
	end
